var documenterSearchIndex = {"docs":
[{"location":"operators/utility/ref_count.html#operator_ref_count-1","page":"ref_count","title":"Ref Count Operator","text":"","category":"section"},{"location":"operators/utility/ref_count.html#","page":"ref_count","title":"ref_count","text":"ref_count","category":"page"},{"location":"operators/utility/ref_count.html#Rx.ref_count","page":"ref_count","title":"Rx.ref_count","text":"ref_count()\n\nMake a ConnectableObservable behave like a ordinary observable and automates the way you can connect to it. Internally it counts the subscriptions to the observable and subscribes (only once) to the source if the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it unsubscribes from the source. This way you can make sure that everything before the published refCount has only a single subscription independently of the number of subscribers to the target observable.\n\nNote that using the share operator is exactly the same as using the publish operator (making the observable hot) and the ref_count() operator in a sequence.\n\nExample\n\nusing Rx\n\nsubject = make_subject(Int, mode = SYNCHRONOUS_SUBJECT_MODE)\nsource  = from(1:5) |> multicast(subject) |> ref_count()\n\nactor1 = logger(\"1\")\nactor2 = logger(\"2\")\n\nsubscription1 = subscribe!(source, actor1)\nsubscription2 = subscribe!(source, actor2)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n;\n\n# output\n[1] Data: 1\n[1] Data: 2\n[1] Data: 3\n[1] Data: 4\n[1] Data: 5\n[1] Completed\n[2] Completed\n\nSee also: AbstractOperator, publish, multicast, share\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/ref_count.html#See-also-1","page":"ref_count","title":"See also","text":"","category":"section"},{"location":"operators/utility/ref_count.html#","page":"ref_count","title":"ref_count","text":"Operators","category":"page"},{"location":"teardown/types/chain.html#teardown_chain-1","page":"Chain","title":"Chain Teardown","text":"","category":"section"},{"location":"teardown/types/chain.html#","page":"Chain","title":"Chain","text":"chain","category":"page"},{"location":"teardown/types/chain.html#Rx.chain","page":"Chain","title":"Rx.chain","text":"chain(t::T) where { T <: Teardown }\n\nCreates a ChainTeardown object with a given teardown t\n\nSee also: Teardown, ChainTeardown\n\n\n\n\n\n","category":"function"},{"location":"teardown/types/chain.html#","page":"Chain","title":"Chain","text":"ChainTeardown","category":"page"},{"location":"teardown/types/chain.html#Rx.ChainTeardown","page":"Chain","title":"Rx.ChainTeardown","text":"ChainTeardown(teardown)\n\nChainTeardown object wraps another teardown and calls its teardown logic on unsubscription.\n\nSee also: Teardown, UnsubscribableTeardownLogic, chain\n\n\n\n\n\n","category":"type"},{"location":"actors/types/keep.html#actor_keep-1","page":"Keep","title":"Keep actor","text":"","category":"section"},{"location":"actors/types/keep.html#","page":"Keep","title":"Keep","text":"keep","category":"page"},{"location":"actors/types/keep.html#Rx.keep","page":"Keep","title":"Rx.keep","text":"keep(::Type{T}) where T\n\nArguments\n\n::Type{T}: Type of keep data\n\nCreation operator for the KeepActor actor.\n\nExamples\n\nusing Rx\n\nactor = keep(Int)\nactor isa KeepActor{Int}\n\n# output\ntrue\n\nSee also: KeepActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/keep.html#","page":"Keep","title":"Keep","text":"KeepActor","category":"page"},{"location":"actors/types/keep.html#Rx.KeepActor","page":"Keep","title":"Rx.KeepActor","text":"KeepActor{D}() where D\n\nKeep actor provides a storage actor. It saves all incoming successful next events in a values array.\n\nExamples\n\nusing Rx\n\nsource = from(1:5)\nactor  = KeepActor{Int}()\n\nsubscribe!(source, actor)\nshow(actor.values)\n\n# output\n[1, 2, 3, 4, 5]\n\nSee also: Actor\n\n\n\n\n\n","category":"type"},{"location":"operators/filtering/last.html#operator_last-1","page":"last","title":"Last Operator","text":"","category":"section"},{"location":"operators/filtering/last.html#","page":"last","title":"last","text":"last","category":"page"},{"location":"operators/filtering/last.html#Base.last","page":"last","title":"Base.last","text":"last(; default = nothing)\n\nCreates a last operator, which returns an Observable that emits only the last item emitted by the source Observable.\n\nArguments\n\ndefault: an optional default value to provide if no values were emitted\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> last(), logger())\n;\n\n# output\n\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from(Int[])\nsubscribe!(source |> last(), logger())\n;\n\n# output\n\n[LogActor] Completed\n\nusing Rx\n\nsource = Rx.from(Int[])\nsubscribe!(source |> last(default = 1), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/last.html#Description-1","page":"last","title":"Description","text":"","category":"section"},{"location":"operators/filtering/last.html#","page":"last","title":"last","text":"last operator returns an Observable that emits only the last item emitted by the source Observable.","category":"page"},{"location":"operators/filtering/last.html#See-also-1","page":"last","title":"See also","text":"","category":"section"},{"location":"operators/filtering/last.html#","page":"last","title":"last","text":"Operators","category":"page"},{"location":"operators/utility/safe.html#operator_safe-1","page":"safe","title":"Safe Operator","text":"","category":"section"},{"location":"operators/utility/safe.html#","page":"safe","title":"safe","text":"safe","category":"page"},{"location":"operators/utility/safe.html#Rx.safe","page":"safe","title":"Rx.safe","text":"safe()\n\nCreates a SafeOperator, which wraps on_subscribe! and each next!, error! and complete! callbacks into try-catch block.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/safe.html#See-also-1","page":"safe","title":"See also","text":"","category":"section"},{"location":"operators/utility/safe.html#","page":"safe","title":"safe","text":"Operators","category":"page"},{"location":"api/actors.html#actors_api-1","page":"Actors","title":"Actors API","text":"","category":"section"},{"location":"api/actors.html#How-to-create-a-custom-Actor-1","page":"Actors","title":"How to create a custom Actor","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"At first custom actor should implement a custom method for the as_actor function. Rx.jl also provides a number of helper actor abstract types with predefined as_actor method behavior (see Traits API section). Optionally custom actor may implement a custom method for the is_exhausted function which is used to check if actor can handle any further message events.","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"using Rx\n\nstruct MyCustomActor end\n\nas_actor(::Type{<:MyCustomActor}) = Rx.BaseActorTrait{Int}()\n\nis_exhausted(actor::MyCustomActor) = # some custom logic here, false by default for all actors.","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"or","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"using Rx\n\nstruct MyCustomActor <: Actor{Int} end # Automatically specifies BaseActorTrait{Int} behavior.","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"Additionally custom actor must provide a custom methods for on_next!, on_error! and/or on_complete! functions. Depending on specified actor trait behavior some methods may or may not be optional.","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"using Rx\n\nstruct MyCustomActor <: Actor{Int} end\n\nRx.on_next!(actor::MyCustomActor, data::Int)  = # custom logic here\nRx.on_error!(actor::MyCustomActor, err)       = # custom logic here\nRx.on_complete!(actor::MyCustomActor)         = # custom logic here","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"or","category":"page"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"using Rx\n\nstruct MyCustomCompletionActor <: CompletionActor{Int} end\n\nRx.on_complete!(actor::MyCustomCompletionActor) = # custom logic here","category":"page"},{"location":"api/actors.html#actors_api_traits-1","page":"Actors","title":"Traits","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"ActorTrait\nas_actor\nBaseActorTrait\nNextActorTrait\nErrorActorTrait\nCompletionActorTrait\nInvalidActorTrait","category":"page"},{"location":"api/actors.html#Rx.ActorTrait","page":"Actors","title":"Rx.ActorTrait","text":"Abstract type for all possible actor traits\n\nSee also: Actor, BaseActorTrait, NextActorTrait, ErrorActorTrait, CompletionActorTrait, InvalidActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.as_actor","page":"Actors","title":"Rx.as_actor","text":"as_actor(::Type)\n\nThis function checks actor trait behavior specification. May be used explicitly to specify actor trait behavior for any object.\n\nSee also: ActorTrait\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.BaseActorTrait","page":"Actors","title":"Rx.BaseActorTrait","text":"Base actor trait specifies actor to listen for all next!, error! and complete! events.\n\nSee also: ActorTrait, Actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.NextActorTrait","page":"Actors","title":"Rx.NextActorTrait","text":"Next actor trait specifies actor to listen for next! events only.\n\nSee also: ActorTrait, NextActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.ErrorActorTrait","page":"Actors","title":"Rx.ErrorActorTrait","text":"Error actor trait specifies actor to listen for error! events only.\n\nSee also: ActorTrait, ErrorActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.CompletionActorTrait","page":"Actors","title":"Rx.CompletionActorTrait","text":"Completion actor trait specifies actor to listen for complete! events only.\n\nSee also: ActorTrait, CompletionActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.InvalidActorTrait","page":"Actors","title":"Rx.InvalidActorTrait","text":"Default actor trait behavior for any object. Actor with such a trait specificaion cannot be used as a valid actor in subscribe! function. Doing so will raise an error.\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Types-1","page":"Actors","title":"Types","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"AbstractActor\nActor\nNextActor\nErrorActor\nCompletionActor","category":"page"},{"location":"api/actors.html#Rx.AbstractActor","page":"Actors","title":"Rx.AbstractActor","text":"Abstract type for any actor object\n\nSee also: Actor, NextActor, ErrorActor, CompletionActor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.Actor","page":"Actors","title":"Rx.Actor","text":"Can be used as a super type for common actor. Automatically specifies a BaseActorTrait trait behavior. Each Actor must implement its own methods for on_next!(actor, data), on_error!(actor, err) and on_complete!(actor) functions.\n\nSee also: AbstractActor, BaseActorTrait, ActorTrait, on_next!, on_error!, on_complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.NextActor","page":"Actors","title":"Rx.NextActor","text":"Can be used as a super type for \"next-only\" actor. Automatically specifies a NextActorTrait trait behavior. Each NextActor must implement its own methods for on_next!(actor, data) function only.\n\nSee also: AbstractActor, NextActorTrait, ActorTrait, on_next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.ErrorActor","page":"Actors","title":"Rx.ErrorActor","text":"Can be used as a super type for \"error-only\" actor. Automatically specifies a ErrorActorTrait trait behavior. Each ErrorActor must implement its own methods for on_error!(actor, err) function only.\n\nSee also: AbstractActor, ErrorActorTrait, ActorTrait, on_error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.CompletionActor","page":"Actors","title":"Rx.CompletionActor","text":"Can be used as a super type for \"completion-only\" actor. Automatically specifies a CompletionActorTrait trait behavior. Each CompletionActor must implement its own methods for on_complete!(actor) function only.\n\nSee also: AbstractActor, CompletionActorTrait, ActorTrait, on_complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Events-1","page":"Actors","title":"Events","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"next!\nerror!\ncomplete!\nis_exhausted","category":"page"},{"location":"api/actors.html#Rx.next!","page":"Actors","title":"Rx.next!","text":"next!(actor, data)\n\nThis function is used to deliver a \"next\" event to an actor with some data\n\nSee also: AbstractActor, on_next!\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.error!","page":"Actors","title":"Rx.error!","text":"error!(actor, err)\n\nThis function is used to deliver a \"error\" event to an actor with some err\n\nSee also: AbstractActor, on_error!\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.complete!","page":"Actors","title":"Rx.complete!","text":"complete!(actor)\n\nThis function is used to deliver a \"complete\" event to an actor\n\nSee also: AbstractActor, on_complete!\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.is_exhausted","page":"Actors","title":"Rx.is_exhausted","text":"is_exhausted(actor)\n\nThis function is used to check if actor can handle any further message events\n\nSee also: AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"on_next!\non_error!\non_complete!","category":"page"},{"location":"api/actors.html#Rx.on_next!","page":"Actors","title":"Rx.on_next!","text":"on_next!(actor, data)\n\nBoth Actor and NextActor objects must implement its own method for on_next! function which will be called on \"next\" event.\n\nSee also: Actor, NextActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.on_error!","page":"Actors","title":"Rx.on_error!","text":"on_error!(actor, err)\n\nBoth Actor and ErrorActor objects must implement its own method for on_error! function which will be called on \"error\" event.\n\nSee also: Actor, ErrorActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.on_complete!","page":"Actors","title":"Rx.on_complete!","text":"on_complete!(actor)\n\nBoth Actor and CompletionActor objects must implement its own method for on_complete! function which will be called on \"complete\" event.\n\nSee also: Actor, ErrorActor\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Factory-1","page":"Actors","title":"Factory","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"AbstractActorFactory\ncreate_actor\nMissingCreateActorFactoryImplementationError","category":"page"},{"location":"api/actors.html#Rx.AbstractActorFactory","page":"Actors","title":"Rx.AbstractActorFactory","text":"Abstract type for all possible actor factories\n\nSee also: Actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.create_actor","page":"Actors","title":"Rx.create_actor","text":"create_actor(::Type{L}, factory::F) where L where { F <: AbstractActorFactory }\n\nActor creator function for a given factory F. Should be implemented explicitly for any AbstractActorFactory object\n\nSee also: AbstractActorFactory, MissingCreateActorFactoryImplementationError\n\n\n\n\n\n","category":"function"},{"location":"api/actors.html#Rx.MissingCreateActorFactoryImplementationError","page":"Actors","title":"Rx.MissingCreateActorFactoryImplementationError","text":"This error will be throw if Julia cannot find specific method of 'create_actor()' function for given actor factory\n\nSee also: AbstractActorFactory, create_actor\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Errors-1","page":"Actors","title":"Errors","text":"","category":"section"},{"location":"api/actors.html#","page":"Actors","title":"Actors","text":"InvalidActorTraitUsageError\nInconsistentSourceActorDataTypesError\nMissingDataArgumentInNextCall\nMissingErrorArgumentInErrorCall\nExtraArgumentInCompleteCall\nMissingOnNextImplementationError\nMissingOnErrorImplementationError\nMissingOnCompleteImplementationError","category":"page"},{"location":"api/actors.html#Rx.InvalidActorTraitUsageError","page":"Actors","title":"Rx.InvalidActorTraitUsageError","text":"This error will be thrown if next!, error! or complete! functions are called with invalid actor object\n\nSee also: next!, error!, complete!, InvalidActorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.InconsistentSourceActorDataTypesError","page":"Actors","title":"Rx.InconsistentSourceActorDataTypesError","text":"This error will be thrown if next! function is called with inconsistent data type\n\nSee also: AbstractActor, Subscribable, next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.MissingDataArgumentInNextCall","page":"Actors","title":"Rx.MissingDataArgumentInNextCall","text":"This error will be thrown if next! function is called without data argument\n\nSee also: next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.MissingErrorArgumentInErrorCall","page":"Actors","title":"Rx.MissingErrorArgumentInErrorCall","text":"This error will be thrown if error! function is called without err argument\n\nSee also: error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.ExtraArgumentInCompleteCall","page":"Actors","title":"Rx.ExtraArgumentInCompleteCall","text":"This error will be thrown if complete! function is called with extra data/err argument\n\nSee also: complete!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.MissingOnNextImplementationError","page":"Actors","title":"Rx.MissingOnNextImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_next!()' function for given actor and data\n\nSee also: on_next!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.MissingOnErrorImplementationError","page":"Actors","title":"Rx.MissingOnErrorImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_error!()' function for given actor\n\nSee also: on_error!\n\n\n\n\n\n","category":"type"},{"location":"api/actors.html#Rx.MissingOnCompleteImplementationError","page":"Actors","title":"Rx.MissingOnCompleteImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_complete!()' function for given actor and data\n\nSee also: on_next!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/array.html#observable_array-1","page":"Array","title":"Array Observable","text":"","category":"section"},{"location":"observables/types/array.html#","page":"Array","title":"Array","text":"from","category":"page"},{"location":"observables/types/array.html#Rx.from","page":"Array","title":"Rx.from","text":"from(x)\n\nCreation operator for the ArrayObservable that emits either a single value if x has a Scalar trait specification or a collection of values if x has a NonScalar trait specification. Throws an ErrorException if x has UndefinedScalarness trait type. To specify scalarness for arbitrary type T some can implement an additional method for scalarness(::Type{<:MyType}) function and to specify scalarness behavior.\n\nArguments\n\nx: an object to be wrapped into array of values\n\nExamples\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from(( 0, 1, 2 ))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from(0)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from(\"Hello, world!\")\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: H\n[LogActor] Data: e\n[LogActor] Data: l\n[LogActor] Data: l\n[LogActor] Data: o\n[LogActor] Data: ,\n[LogActor] Data:\n[LogActor] Data: w\n[LogActor] Data: o\n[LogActor] Data: r\n[LogActor] Data: l\n[LogActor] Data: d\n[LogActor] Data: !\n[LogActor] Completed\n\n\nSee also: ArrayObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/array.html#","page":"Array","title":"Array","text":"ArrayObservable","category":"page"},{"location":"observables/types/array.html#Rx.ArrayObservable","page":"Array","title":"Rx.ArrayObservable","text":"ArrayObservable{D}(values::Vector{D})\n\nArrayObservable wraps a regular Julia array into a synchronous observable\n\nConstructor arguments\n\nvalues: array of values to be wrapped\n\nSee also: Subscribable, from\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#teardown_api-1","page":"Teardown","title":"Teardown API","text":"","category":"section"},{"location":"api/teardown.html#","page":"Teardown","title":"Teardown","text":"Any subscription-like object should implement a valid teardown logic.","category":"page"},{"location":"api/teardown.html#Example-1","page":"Teardown","title":"Example","text":"","category":"section"},{"location":"api/teardown.html#","page":"Teardown","title":"Teardown","text":"using Rx\n\nstruct MuCustomSubscription <: Teardown\n    # some fields here\nend\n\nRx.as_teardown(::Type{<:MuCustomSubscription}) = UnsubscribableTeardownLogic()\n\nfunction on_unsubscribe!(subscription::MyCustomSubscription)\n    # dispose resources here\nend","category":"page"},{"location":"api/teardown.html#Traits-1","page":"Teardown","title":"Traits","text":"","category":"section"},{"location":"api/teardown.html#","page":"Teardown","title":"Teardown","text":"TeardownLogic\nas_teardown\nUnsubscribableTeardownLogic\non_unsubscribe!\nCallableTeardownLogic\nVoidTeardownLogic\nInvalidTeardownLogic","category":"page"},{"location":"api/teardown.html#Rx.TeardownLogic","page":"Teardown","title":"Rx.TeardownLogic","text":"Abstract type for all possible teardown logic traits.\n\nSee also: UnsubscribableTeardownLogic, CallableTeardownLogic, VoidTeardownLogic, InvalidTeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.as_teardown","page":"Teardown","title":"Rx.as_teardown","text":"as_teardown(::Type)\n\nThis function checks teardown trait behavior specification. Should be used explicitly to specify teardown logic trait behavior for any object.\n\nExamples\n\nusing Rx\n\nstruct MySubscription <: Teardown end\n\nRx.as_teardown(::Type{<:MySubscription}) = UnsubscribableTeardownLogic()\nRx.on_unsubscribe!(s::MySubscription)    = println(\"Unsubscribed!\")\n\nsubscription = MySubscription()\nunsubscribe!(subscription)\n;\n\n# output\n\nUnsubscribed!\n\nSee also: Teardown, TeardownLogic\n\n\n\n\n\n","category":"function"},{"location":"api/teardown.html#Rx.UnsubscribableTeardownLogic","page":"Teardown","title":"Rx.UnsubscribableTeardownLogic","text":"Unsubscribable teardown logic trait behavior. Unsubscribable teardown object must define its own method for on_unsubscribe!() function which will be invoked when actor decides to unsubscribe! from Observable.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.on_unsubscribe!","page":"Teardown","title":"Rx.on_unsubscribe!","text":"on_unsubscribe!(teardown)\n\nEach valid teardown object with UnsubscribableTeardownLogic trait behavior must implement its own method for on_unsubscribe!() function which will be invoked when actor decides to unsubscribe! from Observable.\n\nSee also: Teardown, TeardownLogic, UnsubscribableTeardownLogic\n\n\n\n\n\n","category":"function"},{"location":"api/teardown.html#Rx.CallableTeardownLogic","page":"Teardown","title":"Rx.CallableTeardownLogic","text":"Callable teardown logic trait behavior. Callable teardown object must be callable (insert meme with a surprised Pikachu here).\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.VoidTeardownLogic","page":"Teardown","title":"Rx.VoidTeardownLogic","text":"Void teardown logic trait behavior. Void teardown object does nothing in unsubscribe! and may not define any additional methods.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.InvalidTeardownLogic","page":"Teardown","title":"Rx.InvalidTeardownLogic","text":"Default teardown logic trait behavour. Invalid teardwon object cannot be used in unsubscribe! function. Doing so will raise an error.\n\nSee also: TeardownLogic, on_unsubscribe!, unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Types-1","page":"Teardown","title":"Types","text":"","category":"section"},{"location":"api/teardown.html#","page":"Teardown","title":"Teardown","text":"Teardown\nunsubscribe!","category":"page"},{"location":"api/teardown.html#Rx.Teardown","page":"Teardown","title":"Rx.Teardown","text":"Abstract type for any teardown object. Each teardown object must be a subtype of Teardown.\n\nSee also: TeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.unsubscribe!","page":"Teardown","title":"Rx.unsubscribe!","text":"unsubscribe!(o::T) where T\n\nunsubscribe! function is used to cancel Observable execution and to dispose any kind of resources used during an Observable execution.\n\nSee also: Teardown, TeardownLogic, on_unsubscribe!\n\n\n\n\n\n","category":"function"},{"location":"api/teardown.html#Errors-1","page":"Teardown","title":"Errors","text":"","category":"section"},{"location":"api/teardown.html#","page":"Teardown","title":"Teardown","text":"InvalidTeardownLogicTraitUsageError\nMissingOnUnsubscribeImplementationError","category":"page"},{"location":"api/teardown.html#Rx.InvalidTeardownLogicTraitUsageError","page":"Teardown","title":"Rx.InvalidTeardownLogicTraitUsageError","text":"This error will be thrown if unsubscribe! function is called with invalid teardown object.\n\nSee also: unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/teardown.html#Rx.MissingOnUnsubscribeImplementationError","page":"Teardown","title":"Rx.MissingOnUnsubscribeImplementationError","text":"This error will be thrown if Julia cannot find specific method of on_unsubscribe!() function for given teardown object.\n\nSee also: on_unsubscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/max.html#operator_max-1","page":"max","title":"Max Operator","text":"","category":"section"},{"location":"operators/mathematical/max.html#","page":"max","title":"max","text":"max","category":"page"},{"location":"operators/mathematical/max.html#Base.max","page":"max","title":"Base.max","text":"max(; from = nothing)\n\nCreates a max operator, which emits a single item: the item with the largest value.\n\nArguments\n\nfrom: optional initial maximum value, if nothing first item from the source will be used as initial instead\n\nProducing\n\nStream of type <: Subscribable{Union{L, Nothing}} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> max(), logger())\n;\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/max.html#Description-1","page":"max","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/max.html#","page":"max","title":"max","text":"The max operator operates on an Observable of similar objects. When the source Observable completes, it emits the item with the largest value.","category":"page"},{"location":"operators/mathematical/max.html#See-also-1","page":"max","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/max.html#","page":"max","title":"max","text":"Operators","category":"page"},{"location":"operators/errors/catch_error.html#operator_catch_error-1","page":"catch_error","title":"Catch Error Operator","text":"","category":"section"},{"location":"operators/errors/catch_error.html#","page":"catch_error","title":"catch_error","text":"catch_error","category":"page"},{"location":"operators/errors/catch_error.html#Rx.catch_error","page":"catch_error","title":"Rx.catch_error","text":"catch_error(selectorFn::Function)\n\nCreates a CatchErrorOperator, which catches errors on the observable to be handled by returning a new observable or throwing an error.\n\nArguments:\n\nselectorFn::Function: a function that takes as arguments err, which is the error, and caught, which is the source observable, in case you'd like to \"retry\" that observable by returning it again. Whatever observable is returned by the selector will be used to continue the observable chain.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from(1:5) |> safe() |> map(Int, (d) -> d == 4 ? error(4) : d) |> catch_error((err, obs) -> of(1))\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 1\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, rerun, logger, safe\n\n\n\n\n\n","category":"function"},{"location":"operators/errors/catch_error.html#See-also-1","page":"catch_error","title":"See also","text":"","category":"section"},{"location":"operators/errors/catch_error.html#","page":"catch_error","title":"catch_error","text":"Operators","category":"page"},{"location":"operators/about.html#section_operators-1","page":"Operator","title":"Operators","text":"","category":"section"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Even though the Observable is the foundation, Rx is mostly useful because of its operators. Operators are the essential pieces that allow complex asynchronous code to be easily composed in a declarative manner.","category":"page"},{"location":"operators/about.html#what_are_operators-1","page":"Operator","title":"What are operators?","text":"","category":"section"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"There are two kinds of operators:","category":"page"},{"location":"operators/about.html#Pipeable-operators-1","page":"Operator","title":"Pipeable operators","text":"","category":"section"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Pipeable Operators are the kind that can be piped to Observables using the syntax source |> operator(). These include the filter() and map() operators. When called, operators do not change the existing Observable instance. Instead, they return a new Observable, whose subscription logic is based on the first Observable.","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"note: Note\nA Pipeable Operator is a function that takes an Observable as its input and returns another Observable. It is a pure operation: the previous Observable remains unmodified.","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"A Pipeable Operator is essentially a pure callable object that accepts one Observable as input and returns another Observable as output. Subscribing to the output Observable will also subscribe to the input Observable.","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"For example, the operator called map() is analogous to the Array method of the same name. Just like the array method map((d) -> d ^ 2, [ 1, 2, 3 ]) yields [ 1, 4, 9 ], the Observable emits 1, 4, 9:","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source |> map(Int, Int, (d) -> d ^ 2), LambdaActor{Int}(\n    on_next = (d) -> println(d)\n))\n\n// Logs:\n// 1\n// 4\n// 9","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Another useful operator is first():","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source |> first(Int), LambdaActor{Int}(\n    on_next     = (d) -> println(d),\n    on_complete = ()  -> \"Completed\"\n))\n\n// Logs:\n// 1\n// Completed","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Note that the map() is constructed on the fly, since it must be given the mapping function to. By contrast, first() could be a constant, but it is nonetheless constructed on the fly. In general, all operators are constructed - whether they need arguments or not.","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"tip: Performance tip\nDo not use lambda based operators in real Julia code as them lack of performance. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() and/or @CreateFilterOperator(), etc..) or implement your own operators without using lambda functions.","category":"page"},{"location":"operators/about.html#Creation-operators-1","page":"Operator","title":"Creation operators","text":"","category":"section"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Distinct from pipeable operators, creation operators are functions that can be used to create an Observable with some common predefined behavior or by joining other Observables. For example: from([ 1, 2, 3 ]) creates an observable that will sequentially emit 1, 2, and 3.","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"source = from([ 1, 2, 3 ])\nsubscribe!(source, LambdaActor{Int}(\n    on_next     = (d) -> println(\"Value: $d\"),\n    on_error    = (e) -> println(\"Oh no, error: $e\")\n    on_complete = ()  -> println(\"Completed\")\n))\n\n// Logs:\n// Value: 1\n// Value: 2\n// Value: 3\n// Completed","category":"page"},{"location":"operators/about.html#Operators-piping-1","page":"Operator","title":"Operators piping","text":"","category":"section"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"Pipeable operators are special objects that can be used like ordinary functions with on_call!(operator, source). In practice however they tend to accumulate and quickly grow unreadable: on_call!(operator1, on_call!(operator2, on_call!(operator3, source))). Therefore, Rx.jl overloads |> for operators and Observables:","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"using Rx\n\nsource = from([ i for i in 1:100 ]) |> filter((d) -> d % 2 === 0) |> map(Int, (d) -> d ^ 2) |> sum()\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 171700\n// [LogActor] Completed","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"It is also possible to create an operator composition. It might be useful to create an alias for some often used operator chain","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"using Rx\n\nmapAndFilter = map(Int, d -> d ^ 2) + filter(d -> d % 2 == 0)\n\nsource = from(1:5) |> mapAndFilter\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 4\n// [LogActor] Data: 16\n// [LogActor] Completed\n\nmapAndFilterAndSum = mapAndFilter + sum()\n\nsource = from(1:5) |> mapAndFilterAndSum\n\nsubscribe!(source, logger())\n\n// Logs\n// [LogActor] Data: 20\n// [LogActor] Completed","category":"page"},{"location":"operators/about.html#","page":"Operator","title":"Operator","text":"For stylistic reasons, on_call!(operator, source) is never used in practice - even if there is only one operator. Instead, source |> operator() is generally preferred.","category":"page"},{"location":"subjects/types/replay.html#subject_replay-1","page":"Replay","title":"ReplaySubject","text":"","category":"section"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"make_replay_subject","category":"page"},{"location":"subjects/types/replay.html#Rx.make_replay_subject","page":"Replay","title":"Rx.make_replay_subject","text":"make_replay_subject(::Type{T}, count::Int; mode::Val{M} = DEFAULT_SUBJECT_MODE) where T where M\n\nCreation operator for the ReplaySubject\n\nSee also: ReplaySubject, make_subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"ReplaySubject","category":"page"},{"location":"subjects/types/replay.html#Rx.ReplaySubject","page":"Replay","title":"Rx.ReplaySubject","text":"ReplaySubject{D, S}(capacity, subject)\n\nA variant of Subject that \"replays\" or emits old values to new subscribers. It buffers a set number of values and will emit those values immediately to any new subscribers in addition to emitting new values to existing subscribers.\n\nArguments\n\ncapacity: how many values to replay\nsubject: Subject base type\n\nSee\n\n\n\n\n\n","category":"type"},{"location":"subjects/types/replay.html#Description-1","page":"Replay","title":"Description","text":"","category":"section"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"A ReplaySubject is similar to a BehaviorSubject in that it can send old values to new subscribers, but it can also record a part of the Observable execution.","category":"page"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"note: Note\nA ReplaySubject records multiple values from the Observable execution and replays them to new subscribers.","category":"page"},{"location":"subjects/types/replay.html#Examples-1","page":"Replay","title":"Examples","text":"","category":"section"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"When creating a ReplaySubject, you can specify how many values to replay:","category":"page"},{"location":"subjects/types/replay.html#","page":"Replay","title":"Replay","text":"using Rx\n\nsubject = make_replay_subject(Int, 3) # buffer 3 values for new subscribers\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\nnext!(subject, 3)\nnext!(subject, 4)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 5)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 1\n// [1] Data: 2\n// [1] Data: 3\n// [1] Data: 4\n// [2] Data: 2\n// [2] Data: 3\n// [2] Data: 4\n// [1] Data: 5\n// [2] Data: 5","category":"page"},{"location":"observables/about.html#section_observables-1","page":"Observable","title":"Observables","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Observables are lazy Push collections of multiple values. They fill the missing spot in the following table:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Type Single Mutliple\nPull Function Iterator\nPush Promise Observable","category":"page"},{"location":"observables/about.html#First-example-1","page":"Observable","title":"First example","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"For example, the following code specifies an Observable that pushes the values 1, 2, 3 immediately (synchronously) when subscribed to, and the value 4 after one second has passed since subscription.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    setTimeout(1000) do\n        next!(actor, 4)\n        complete!(actor)\n    end\nend","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"To invoke the Observable and inspect these values, we need to subscribe to it.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    setTimeout(1000) do\n        next!(actor, 4)\n        complete!(actor)\n    end\nend\n\nprintln(\"Just before subscribe\")\nsubscribe!(source, lambda(\n    on_next     = (d) -> println(d),\n    on_complete = ()  -> println(\"Completed\")\n))\nprintln(\"Just after subscribe\")\n\n# Logs\n# Just before subscribe\n# 1\n# 2\n# 3\n# Just after subscribe\n# 4\n# Completed","category":"page"},{"location":"observables/about.html#Pull-vs-Push-1","page":"Observable","title":"Pull vs Push","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Pull and Push are two different protocols that describe how a data Producer communicates with a data Consumer.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"In a Pull system, the Consumer determines when it receives data from the Producer. The Producer itself is unaware of when the data are delivered to the Consumer.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Every Julia Function is a Pull system. The function is a Producer of data, and the code that calls the function is consuming data by \"pulling\" a return value from the call.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Type PRODUCER CONSUMER\nPull Passive: produces data when requested. Active: decides when data is requested.\nPush Active: produces data at its own pace. Passive: reacts to received data.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"In Push systems, the Producer determines when to send data to the Consumer. The Consumer is unaware of when it will receive that data.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Futures and promises are the most common type of Push systems today. A Promise (the Producer) delivers a resolved value to registered callbacks (the Consumers). Unlike functions, it is the Promise that determines precisely when a value is \"pushed\" to the callbacks.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Rx.jl introduces Observables, a new Push system for Julia. An Observable is a Producer of multiple values, \"pushing\" them to Observers (Consumers or Actors).","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"A Function is a lazily evaluated computation that synchronously returns a single value on invocation.\nA Generator is a lazily evaluated computation that synchronously returns zero to (potentially) infinite values on iteration.\nA Promise is a computation that may (or may not) eventually return a single value.\nAn Observable is a lazily evaluated computation that can synchronously or asynchronously return zero to (potentially) infinite values from the time it's invoked.","category":"page"},{"location":"observables/about.html#Observables-as-generalizations-of-functions-1","page":"Observable","title":"Observables as generalizations of functions","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"In contrast to functions, Observables can \"return\" multiple values over time. For example, functions can't do this:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"function foo()\n    println(\"Hello!\")\n    return 0\n    return 1 # Dead code, will never happen\nend","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Observables, however, can do this:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nfoo = make(Int) do actor\n    next!(actor, 0)\n    next!(actor, 1)\n    complete!(actor)\nend\n","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Observables can also \"return\" values asynchronously:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nfoo = make(Int) do actor\n    setTimeout(1000) do\n        next!(actor, 0)\n        complete!(actor)\n    end\nend","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"func() means \"give me one value synchronously\"\nsubscribe(observable, ...) means \"give me any amount of values, either synchronously or asynchronously\"","category":"page"},{"location":"observables/about.html#Anatomy-of-an-Observable-1","page":"Observable","title":"Anatomy of an Observable","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Observables are (1) created using creation operators (it is also possible to build an Observable from scratch with custom logic); (2) subscribed to with an Actor; (3) execute to deliver next! / error! / complete! notifications to the Actor, and (4) their execution may be disposed. These four aspects are all encoded in an Observable instance, but some of these aspects are related to other types, such as Subscribable and Subscription.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"The core responsibilities of an Observable are:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Creating Observables\nSubscribing to Observables\nExecuting the Observable\nDisposing Observables","category":"page"},{"location":"observables/about.html#Creating-Observables-1","page":"Observable","title":"Creating Observables","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"You can create an Observable in various ways using Creation operators. You can also build an Observable from scratch. To see how you can build an Observable with custom logic, consult the API Section.","category":"page"},{"location":"observables/about.html#Subscribing-to-Observables-1","page":"Observable","title":"Subscribing to Observables","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"The Observable source in the example can be subscribed to.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nsubscribe!(source, lambda(\n    on_next = (d) -> println(d)\n))","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"This example shows how subscribe calls are not shared among multiple Actors of the same Observable. When calling subscribe! with an Actor, the function on_subscribe! that is attached to this particular Observable is executed for that given actor. Each call to subscribe! triggers its own independent setup for that given actor.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"note: Note\nSubscribing to an Observable is like calling a function, providing callbacks where the data will be delivered to.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"A subscribe! call simply delivers initial values or events to an Actor.","category":"page"},{"location":"observables/about.html#Executing-Observables-1","page":"Observable","title":"Executing Observables","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"The execution produces multiple values over time, either synchronously or asynchronously.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"An Observable Execution can deliver three types of notifications:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"Next: sends a value, such as an Int, String, Dict, etc.;\nError: sends any error as a value;\nComplete: does not send a value.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"\"Next\" notifications are the most important and most common type: they represent actual data being delivered to an subscriber. \"Error\" and \"Complete\" notifications terminate the Observable Execution.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"note: Note\nIn an Observable Execution, any number of Next notifications may be delivered. However, once a single Error or Complete notification is delivered, nothing else can be delivered afterwards.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"The following is an example of an Observable execution that delivers three Next notifications and subsequently completes:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nsource = make(Int) do actor\n    next!(actor, 1)\n    next!(actor, 2)\n    next!(actor, 3)\n    complete!(actor)\nend\n\n# or the same with creation operator\n\nsource = from([ 1, 2, 3 ])","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"It is advised to wrap any code in subscribe by a try/catch block that delivers an Error notification upon an exception:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"using Rx\n\nsource = make(Int) do actor\n    try\n        next!(actor, 1)\n        next!(actor, 2)\n        next!(actor, 3)\n        complete!(actor)\n    catch e\n        error!(actor, e)\n    end\nend\n","category":"page"},{"location":"observables/about.html#Disposing-Observable-Executions-1","page":"Observable","title":"Disposing Observable Executions","text":"","category":"section"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"It is common for an Actor to abort execution of an Observable Execution. Once the Actor is done receiving values, it may stop the execution in order to free computation power or memory resources.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"When subscribe! is called, the Actor gets attached to the newly created Observable execution. This call also returns an object, the Subscription:","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"subscription = subscribe!(source, actor)","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"The Subscription represents the ongoing execution, and has a minimal API that allows you to cancel the execution. Read more about Subscription type here.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"With","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"unsubscribe!(subscription)","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"you can cancel the ongoing execution.","category":"page"},{"location":"observables/about.html#","page":"Observable","title":"Observable","text":"note: Note\nsubscribe! returns a Subscription that represents the ongoing execution. Simply call unsubscribe! on the Subscription to cancel the execution.","category":"page"},{"location":"observables/types/never.html#observable_never-1","page":"Never","title":"Never Observable","text":"","category":"section"},{"location":"observables/types/never.html#","page":"Never","title":"Never","text":"never","category":"page"},{"location":"observables/types/never.html#Rx.never","page":"Never","title":"Rx.never","text":"never(T = Any)\n\nCreation operator for the NeverObservable that emits neither values nor errors nor the completion notification. It can be used for testing purposes or for composing with other Observables. Please note that by never emitting a complete notification, this Observable keeps the subscription from being disposed automatically. Subscriptions need to be manually disposed.\n\nArguments\n\nT: Type of Observable data, optional, Any is the default\n\nExamples\n\nusing Rx\n\nsource = never()\nsubscribe!(source, logger())\n;\n\n# output\n\n\nSee also: NeverObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/never.html#","page":"Never","title":"Never","text":"NeverObservable","category":"page"},{"location":"observables/types/never.html#Rx.NeverObservable","page":"Never","title":"Rx.NeverObservable","text":"NeverObservable{D}()\n\nAn Observable that emits no items to the Observer and never completes.\n\nType parameters\n\nD: Type of Observable data\n\nSee also: Subscribable, never\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/about.html#Utility-category-1","page":"About utility operators","title":"Utility category","text":"","category":"section"},{"location":"operators/utility/about.html#","page":"About utility operators","title":"About utility operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in utility category.","category":"page"},{"location":"operators/utility/about.html#","page":"About utility operators","title":"About utility operators","text":"tap\ndelay\nsafe\nnoop\nref_count","category":"page"},{"location":"operators/utility/about.html#See-also-1","page":"About utility operators","title":"See also","text":"","category":"section"},{"location":"operators/utility/about.html#","page":"About utility operators","title":"About utility operators","text":"Operators","category":"page"},{"location":"operators/all.html#operators_list-1","page":"All","title":"List of all available operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc.","category":"page"},{"location":"operators/all.html#Creation-operators-1","page":"All","title":"Creation operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"make\nof\nfrom\nerror\nnever\ncompleted\ntimer\ninterval\ncombined","category":"page"},{"location":"operators/all.html#Transformation-operators-1","page":"All","title":"Transformation operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"map\nscan\nenumerate\nuppercase\nlowercase\nto_array","category":"page"},{"location":"operators/all.html#Filtering-operators-1","page":"All","title":"Filtering operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"filter\nsome\ntake\nfirst\nlast","category":"page"},{"location":"operators/all.html#Mathematical-and-Aggregate-operators-1","page":"All","title":"Mathematical and Aggregate operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"count\nmax\nmin\nreduce\nsum","category":"page"},{"location":"operators/all.html#Error-handling-operators-1","page":"All","title":"Error handling operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"catch_error\nrerun","category":"page"},{"location":"operators/all.html#Multicasting-operators-1","page":"All","title":"Multicasting operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"multicast\npublish\npublish_behavior\npublish_replay\nshare\nshare_replay","category":"page"},{"location":"operators/all.html#Utility-operators-1","page":"All","title":"Utility operators","text":"","category":"section"},{"location":"operators/all.html#","page":"All","title":"All","text":"tap\ndelay\nsafe\nnoop\nref_count","category":"page"},{"location":"actors/types/lambda.html#actor_lambda-1","page":"Lambda","title":"Lambda actor","text":"","category":"section"},{"location":"actors/types/lambda.html#","page":"Lambda","title":"Lambda","text":"lambda","category":"page"},{"location":"actors/types/lambda.html#Rx.lambda","page":"Lambda","title":"Rx.lambda","text":"lambda(; on_next = nothing, on_error = nothing, on_complete = nothing)\nlambda(::Type{T}; on_next = nothing, on_error = nothing, on_complete = nothing) where T\n\nCreation operator for the 'LambdaActor' actor.\n\nExamples\n\nusing Rx\n\nactor = lambda(Int; on_next = (d) -> println(d))\nactor isa LambdaActor{Int}\n\n# output\ntrue\n\nSee also: LambdaActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/lambda.html#","page":"Lambda","title":"Lambda","text":"LambdaActor","category":"page"},{"location":"actors/types/lambda.html#Rx.LambdaActor","page":"Lambda","title":"Rx.LambdaActor","text":"LambdaActor{D}(; on_next = nothing, on_error = nothing, on_complete = nothing) where D\n\nLambda actor wraps on_next, on_error, on_complete callbacks for data, error and complete events.\n\nConstructor arguments\n\non_next: Callback for data event. Optional. Default is nothing.\non_error: Callback for error event. Optional. Default is nothing.\non_complete: Callback for complete event. Optional. Default is nothing.\n\nExamples\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, LambdaActor{Int}(\n    on_next = (d) -> println(\"Data event: $d\")\n))\n;\n\n# output\n\nData event: 0\nData event: 1\nData event: 2\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, LambdaActor{Int}(\n    on_complete = () -> println(\"Completed\")\n));\n;\n\n# output\n\nCompleted\n\n\nSee also: Actor\n\n\n\n\n\n","category":"type"},{"location":"actors/types/lambda.html#","page":"Lambda","title":"Lambda","text":"tip: Performance tip\nFor performance reasons, do not use lambda-based actors in production; use them for debugging only.","category":"page"},{"location":"utils.html#Utils-1","page":"Utils","title":"Utils","text":"","category":"section"},{"location":"utils.html#","page":"Utils","title":"Utils","text":"setTimeout","category":"page"},{"location":"utils.html#Rx.setTimeout","page":"Utils","title":"Rx.setTimeout","text":"setTimeout(f::Function, timeout::Int)\n\nCreates a Task which will asynchornously invoke fucntion f after specified timeout time in milliseconds.\n\nArguments\n\nf::Function, function to be invoked asynchronously\ntimeout::Int, timeout in milliseconds\n\nExamples\n\nusing Rx\nusing Dates\n\nprintln(\"Before: \", Dates.format(now(), \"MM:SS\"))\nsetTimeout(1000) do\n    println(\"Inside: \", Dates.format(now(), \"MM:SS\"))\nend\nprintln(\"Right after: \", Dates.format(now(), \"MM:SS\"))\n;\n\n# Logs\n# Before: 20:59\n# Right after: 20:59\n# Inside: 21:00\n\n\n\n\n\n","category":"function"},{"location":"observables/types/completed.html#observable_completed-1","page":"Completed","title":"Completed Observable","text":"","category":"section"},{"location":"observables/types/completed.html#","page":"Completed","title":"Completed","text":"completed","category":"page"},{"location":"observables/types/completed.html#Rx.completed","page":"Completed","title":"Rx.completed","text":"completed(T = Any)\n\nCreation operator for the CompletedObservable that emits no items to the Actor and immediately sends a complete notification on subscription.\n\nArguments\n\nT: type of output data source, optional, Any is the default\n\nExamples\n\nusing Rx\n\nsource = completed(Int)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Completed\n\n\nSee also: CompletedObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/completed.html#","page":"Completed","title":"Completed","text":"CompletedObservable","category":"page"},{"location":"observables/types/completed.html#Rx.CompletedObservable","page":"Completed","title":"Rx.CompletedObservable","text":"CompletedObservable{D}()\n\nObservable that emits no items to the Actor and immediately sends a complete notification on subscription.\n\nSee also: Subscribable, completed\n\n\n\n\n\n","category":"type"},{"location":"operators/utility/tap.html#operator_tap-1","page":"tap","title":"Tap Operator","text":"","category":"section"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"tap","category":"page"},{"location":"operators/utility/tap.html#Rx.tap","page":"tap","title":"Rx.tap","text":"tap(tapFn::Function)\n\nCreates a tap operator, which performs a side effect for every emission on the source Observable, but return an Observable that is identical to the source.\n\nArguments\n\ntapFn::Function: side-effect tap function with (data) -> Nothing signature\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> tap((d) -> println(\"In tap: $d\")), logger())\n;\n\n# output\n\nIn tap: 1\n[LogActor] Data: 1\nIn tap: 2\n[LogActor] Data: 2\nIn tap: 3\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/tap.html#Description-1","page":"tap","title":"Description","text":"","category":"section"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"Returns an Observable that resembles the source Observable, but modifies it so that the provided Observer is called to perform a side effect for every value emitted by the source.","category":"page"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"This operator is useful for debugging your Observables, verifying correct values, or performing other side effects.","category":"page"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"Note: this operator differs from a subscribe on the Observable. If the Observable returned by tap is not subscribed, the side effects specified by the Observer will never happen. tap therefore simply spies on existing execution, it does not trigger an execution to happen like subscribe does.","category":"page"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"tip: Performance tip\nDo not use lambda based operators in real Julia code as them lack of performance. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() and/or @CreateFilterOperator(), etc..) or implement your own operators without using lambda functions.","category":"page"},{"location":"operators/utility/tap.html#@CreateTapOperator-macro-1","page":"tap","title":"@CreateTapOperator macro","text":"","category":"section"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"For performance reasons Rx.jl library provides a special macro for creating custom tap operators.","category":"page"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"@CreateTapOperator","category":"page"},{"location":"operators/utility/tap.html#Rx.@CreateTapOperator","page":"tap","title":"Rx.@CreateTapOperator","text":"@CreateTapOperator(name, tapFn)\n\nCreates a custom tap operator, which can be used as nameTapOperator().\n\nArguments\n\nname: custom operator name\ntapFn: side-effect tap function\n\nGenerates\n\nnameTapOperator() function\n\nExamples\n\nusing Rx\n\n@CreateTapOperator(\"Print\", (d) -> println(\"In tap: $d\"))\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> PrintTapOperator(), LoggerActor{Int}())\n;\n\n# output\n\nIn tap: 1\n[LogActor] Data: 1\nIn tap: 2\n[LogActor] Data: 2\nIn tap: 3\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"macro"},{"location":"operators/utility/tap.html#See-also-1","page":"tap","title":"See also","text":"","category":"section"},{"location":"operators/utility/tap.html#","page":"tap","title":"tap","text":"Operators","category":"page"},{"location":"observables/types/function.html#observable_function-1","page":"Function","title":"Function Observable","text":"","category":"section"},{"location":"observables/types/function.html#","page":"Function","title":"Function","text":"make","category":"page"},{"location":"observables/types/function.html#Rx.make","page":"Function","title":"Rx.make","text":"make(f::Function, type::Type{D})\n\nCreation operator for the FunctionObservable.\n\nArguments\n\nf: function to be invoked on subscription\ntype: type of data in observable\n\nExamples\n\nusing Rx\n\nsource = make(Int) do actor\n    next!(actor, 0)\n    complete!(actor)\nend\n\nsubscription = subscribe!(source, logger());\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\n\nusing Rx\n\nsource = make(Int) do actor\n    next!(actor, 0)\n    setTimeout(100) do\n        next!(actor, 1)\n        complete!(actor)\n    end\nend\n\nsubscription = subscribe!(source, logger())\nunsubscribe!(subscription)\n;\n\n# output\n\n[LogActor] Data: 0\n\n\nSee also: FunctionObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/function.html#","page":"Function","title":"Function","text":"FunctionObservable","category":"page"},{"location":"observables/types/function.html#Rx.FunctionObservable","page":"Function","title":"Rx.FunctionObservable","text":"FunctionObservable{D}(f::Function)\n\nFunctionObservable wraps a callback f, which is called when the Observable is initially subscribed to. This function is given an Actor, to which new values can be nexted (with next!(actor, data)), or an error! method can be called to raise an error, or complete! can be called to notify of a successful completion.\n\nArguments\n\nf: function to be invoked on subscription\n\nSee also: Subscribable, make\n\n\n\n\n\n","category":"type"},{"location":"todo.html#TODO-1","page":"TODO","title":"TODO","text":"","category":"section"},{"location":"todo.html#","page":"TODO","title":"TODO","text":"This package in under development and some features of the reactive framework not yet implemented.","category":"page"},{"location":"todo.html#List-of-not-implemented-features-1","page":"TODO","title":"List of not implemented features","text":"","category":"section"},{"location":"todo.html#","page":"TODO","title":"TODO","text":"High-order observables and operators (mergeMap, concatMap, etc..)\nJoin operators: combineLatest, concatAll, etc..\nMore transformation, filtering, utility operators\nMore tests\nPossible bugs (welcome to open a PR)","category":"page"},{"location":"operators/mathematical/count.html#operator_count-1","page":"count","title":"Count Operator","text":"","category":"section"},{"location":"operators/mathematical/count.html#","page":"count","title":"count","text":"count","category":"page"},{"location":"operators/mathematical/count.html#Base.count","page":"count","title":"Base.count","text":"count()\n\nCreates a count operator, which counts the number of emissions on the source and emits that number when the source completes.\n\nProducing\n\nStream of type <: Subscribable{Int}\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> count(), logger())\n;\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/count.html#Description-1","page":"count","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/count.html#","page":"count","title":"count","text":"count transforms an Observable that emits values into an Observable that emits a single value that represents the number of values emitted by the source Observable. If the source Observable terminates with an error, count will pass this error notification along without emitting a value first. If the source Observable does not terminate at all, count will neither emit a value nor terminate.","category":"page"},{"location":"operators/mathematical/count.html#Example-1","page":"count","title":"Example","text":"","category":"section"},{"location":"operators/mathematical/count.html#","page":"count","title":"count","text":"Counts how many values source Observable have emitted before the complete event happened","category":"page"},{"location":"operators/mathematical/count.html#","page":"count","title":"count","text":"using Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> count(), LoggerActor{Int}())\n\n# output\n\n[LogActor] Data: 42\n[LogActor] Completed","category":"page"},{"location":"operators/mathematical/count.html#See-also-1","page":"count","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/count.html#","page":"count","title":"count","text":"Operators","category":"page"},{"location":"operators/transformation/uppercase.html#operator_uppercase-1","page":"uppercase","title":"Uppercase Operator","text":"","category":"section"},{"location":"operators/transformation/uppercase.html#","page":"uppercase","title":"uppercase","text":"uppercase","category":"page"},{"location":"operators/transformation/uppercase.html#Base.Unicode.uppercase","page":"uppercase","title":"Base.Unicode.uppercase","text":"uppercase()\n\nCreates an uppercase operator, which forces each value to be in upper case\n\nProducing\n\nStream of type <: Subscribable{L} where L referes to type of data of input Observable\n\nExamples\n\nusing Rx\n\nsource = of(\"Hello, world!\")\nsubscribe!(source |> uppercase(), logger())\n;\n\n# output\n\n[LogActor] Data: HELLO, WORLD!\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/uppercase.html#See-also-1","page":"uppercase","title":"See also","text":"","category":"section"},{"location":"operators/transformation/uppercase.html#","page":"uppercase","title":"uppercase","text":"Operators, map, lowercase","category":"page"},{"location":"observables/types/file.html#observable_file-1","page":"File","title":"File Observable","text":"","category":"section"},{"location":"observables/types/file.html#","page":"File","title":"File","text":"file","category":"page"},{"location":"observables/types/file.html#Rx.file","page":"File","title":"Rx.file","text":"file(path::String)\n\nCreation operator for the SyncFileObservable with a given path.\n\nSee also: SyncFileObservable\n\n\n\n\n\n","category":"function"},{"location":"observables/types/file.html#","page":"File","title":"File","text":"SyncFileObservable","category":"page"},{"location":"observables/types/file.html#Rx.SyncFileObservable","page":"File","title":"Rx.SyncFileObservable","text":"SyncFileObservable(path::String)\n\nFile observable, which synchronously emits content of the file line by line as a String objects on subscription.\n\nSee also: file, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/reduce.html#operator_reduce-1","page":"reduce","title":"Reduce Operator","text":"","category":"section"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"reduce","category":"page"},{"location":"operators/mathematical/reduce.html#Base.reduce","page":"reduce","title":"Base.reduce","text":"reduce(::Type{R}, reduceFn::Function, seed::Union{R, Nothing} = nothing) where R\n\nCreates a reduce operator, which applies a given accumulator reduceFn function over the source Observable, and returns the accumulated result when the source completes, given an optional seed value. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.\n\nArguments\n\n::Type{R}: the type of data of transformed value\nreduceFn::Function: transformation function with (data::T, current::R) -> R signature\nseed::R: optional seed accumulation value\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:10 ])\nsubscribe!(source |> reduce(Vector{Int}, (d, c) -> [ c..., d ], Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> reduce(Int, +), logger())\n;\n\n# output\n\n[LogActor] Data: 903\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/reduce.html#Description-1","page":"reduce","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"reduce applies an accumulator function to each value of the source Observable (from the past) and reduces it to a single value that is emitted by the output Observable. Note that reduce will only emit one value, only when the source Observable completes. It is equivalent to applying scan followed by last.","category":"page"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"It returns an Observable that applies a specified accumulator function to each item emitted by the source Observable. If a seed value is specified, then that value will be used as the initial value of the accumulator. If no seed value is specified, the first item of the source is used as the seed.","category":"page"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"tip: Performance tip\nFor performance reasons, do not use lambda based operators in production Julia code. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() or @CreateFilterOperator(), etc..), or implement custom operators without using lambda functions.","category":"page"},{"location":"operators/mathematical/reduce.html#@CreateReduceOperator-macro-1","page":"reduce","title":"@CreateReduceOperator macro","text":"","category":"section"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"For performance reasons Rx.jl library provides a special macro for creating custom (and pure) reduce operators.","category":"page"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"@CreateReduceOperator","category":"page"},{"location":"operators/mathematical/reduce.html#Rx.@CreateReduceOperator","page":"reduce","title":"Rx.@CreateReduceOperator","text":"@CreateReduceOperator(name, L, R, reduceFn)\n\nCreates a custom reduce operator, which can be used as nameReduceOperator().\n\nArguments\n\nname: custom operator name\nL: type of input data\nR: type of output data after reduceFn projection\nreduceFn: accumulator function, assumed to be pure\n\nGenerates\n\nnameReduceOperator(seed::R) function\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\n@CreateReduceOperator(IntoArray, Int, Vector{Int}, (d, c) -> [ c..., d ])\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> IntoArrayReduceOperator(Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, TypedOperator, ProxyObservable, reduce, logger\n\n\n\n\n\n","category":"macro"},{"location":"operators/mathematical/reduce.html#See-also-1","page":"reduce","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/reduce.html#","page":"reduce","title":"reduce","text":"Operators, scan, last","category":"page"},{"location":"operators/filtering/some.html#operator_some-1","page":"some","title":"Some Operator","text":"","category":"section"},{"location":"operators/filtering/some.html#","page":"some","title":"some","text":"some","category":"page"},{"location":"operators/filtering/some.html#Rx.some","page":"some","title":"Rx.some","text":"some()\n\nCreates a some operator, which filters out nothing items by the source Observable by emitting only those that not equal to nothing.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream <: Subscribable{Union{L, Nothing}}\n\nExamples\n\nusing Rx\n\nsource = Rx.from([ 1, nothing, 3 ])\nsubscribe!(source |> some(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, max, min, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/some.html#Description-1","page":"some","title":"Description","text":"","category":"section"},{"location":"operators/filtering/some.html#","page":"some","title":"some","text":"This operator takes values from the source Observable and only emits those values that are not nothing.","category":"page"},{"location":"operators/filtering/some.html#See-also-1","page":"some","title":"See also","text":"","category":"section"},{"location":"operators/filtering/some.html#","page":"some","title":"some","text":"Operators, filter","category":"page"},{"location":"operators/multicasting/publish.html#operator_publish-1","page":"publish","title":"Publish Operators","text":"","category":"section"},{"location":"operators/multicasting/publish.html#","page":"publish","title":"publish","text":"publish\npublish_behavior\npublish_replay","category":"page"},{"location":"operators/multicasting/publish.html#Rx.publish","page":"publish","title":"Rx.publish","text":"publish(; mode::Val{M} = DEFAULT_SUBJECT_MODE) where M\n\npublish() is a shortcut for multicast(make_subject_factory())\n\nSee also: AbstractOperator, multicast, make_subject\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish.html#Rx.publish_behavior","page":"publish","title":"Rx.publish_behavior","text":"publish_behavior(default; mode::Val{M} = DEFAULT_SUBJECT_MODE) where M\n\npublish_behavior(default) is a shortcut for multicast(make_behavior_subject_factory(default))\n\nSee also: AbstractOperator, multicast, make_behavior_subject\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish.html#Rx.publish_replay","page":"publish","title":"Rx.publish_replay","text":"publish_replay(count; mode::Val{M} = DEFAULT_SUBJECT_MODE) where M\n\npublish_replay(count) is a shortcut for multicast(make_replay _subject_factory(count))\n\nSee also: AbstractOperator, multicast, make_replay_subject\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/publish.html#See-also-1","page":"publish","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/publish.html#","page":"publish","title":"publish","text":"Operators","category":"page"},{"location":"index.html#Rx.jl-Documentation-1","page":"Home","title":"Rx.jl Documentation","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Welcome to the documentation for Rx.jl.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"This documentation is an adaptation of the RxJS library documentation.","category":"page"},{"location":"index.html#Table-of-Contents-1","page":"Home","title":"Table of Contents","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Pages = [\n  \"getting-started.md\",\n  \"observables/about.md\",\n  \"actors/about.md\",\n  \"teardown/about.md\",\n  \"operators/about.md\",\n  \"operators/piping.md\",\n  \"operators/create-new-operator.md\",\n  \"operators/high-order.md\",\n  \"todo.md\",\n  \"contributing.md\",\n  \"utils.md\"\n]\nDepth = 2","category":"page"},{"location":"index.html#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"","category":"page"},{"location":"actors/types/logger.html#actor_logger-1","page":"Logger","title":"Logger actor","text":"","category":"section"},{"location":"actors/types/logger.html#","page":"Logger","title":"Logger","text":"logger","category":"page"},{"location":"actors/types/logger.html#Rx.logger","page":"Logger","title":"Rx.logger","text":"logger(name = \"LogActor\")\nlogger(::Type{T}, name = \"LogActor\") where T\n\nCreation operator for the LoggerActor actor.\n\nExamples\n\nusing Rx\n\nactor = logger(Int)\nactor isa LoggerActor{Int}\n\n# output\ntrue\n\nSee also: LoggerActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/logger.html#","page":"Logger","title":"Logger","text":"LoggerActor","category":"page"},{"location":"actors/types/logger.html#Rx.LoggerActor","page":"Logger","title":"Rx.LoggerActor","text":"LoggerActor{D}(name::String = \"LogActor\") where D\n\nThe LoggerActor logs all next!/error!/complete! events that are sent from an Observable.\n\nConstructor arguments\n\nname: name of the logger. Optional. Default is LogActor.\n\nExamples\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, LoggerActor{Int}())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source, LoggerActor{Int}(\"CustomName\"))\n;\n\n# output\n\n[CustomName] Data: 0\n[CustomName] Data: 1\n[CustomName] Data: 2\n[CustomName] Completed\n\n\nSee also: Actor, logger\n\n\n\n\n\n","category":"type"},{"location":"operators/multicasting/about.html#Multicasting-category-1","page":"About multicasting operators","title":"Multicasting category","text":"","category":"section"},{"location":"operators/multicasting/about.html#","page":"About multicasting operators","title":"About multicasting operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in multicasting category.","category":"page"},{"location":"operators/multicasting/about.html#","page":"About multicasting operators","title":"About multicasting operators","text":"multicast\npublish\npublish_behavior\npublish_replay\nshare\nshare_replay","category":"page"},{"location":"operators/multicasting/about.html#See-also-1","page":"About multicasting operators","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/about.html#","page":"About multicasting operators","title":"About multicasting operators","text":"Operators","category":"page"},{"location":"teardown/about.html#section_subscription-1","page":"Subscription","title":"Subscription","text":"","category":"section"},{"location":"teardown/about.html#","page":"Subscription","title":"Subscription","text":"A Subscription represents a disposable resource, usually the execution of an Observable. A Subscription has one important method: unsubscribe!(teardown), which takes some teardown logic object as one argument and disposes the resource held by the subscription.","category":"page"},{"location":"teardown/about.html#","page":"Subscription","title":"Subscription","text":"using Rx\n\nsource = make_subject(Int)\n\nnext!(source, 0) # Logs nothing as there is no subscribers\n\nsubscription = subscribe!(source, logger())\n\nnext!(source, 1) # Logs [LogActor] Data: 1 into standard output\n\nunsubscribe!(subscription)\n\nnext!(source, 2) # Logs nothing as a single one actor has unsubscribed","category":"page"},{"location":"teardown/about.html#","page":"Subscription","title":"Subscription","text":"note: Note\nA Subscription essentially just has its own specific method for unsubscribe!() function which releases resources or cancel Observable executions. Any Observable has to return a valid Teardown object.","category":"page"},{"location":"teardown/about.html#","page":"Subscription","title":"Subscription","text":"For more information about subscription and teardown logic see the API Section","category":"page"},{"location":"contributing.html#Contribution-guidelines-1","page":"Contributing","title":"Contribution guidelines","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We welcome all possible contributors. This page details the some of the guidelines that should be followed when contributing to this package.","category":"page"},{"location":"contributing.html#Reporting-bugs-1","page":"Contributing","title":"Reporting bugs","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We track bugs using GitHub issues. We encourage you to write complete, specific, reproducible bug reports. Mention the versions of Julia and Rx.jl for which you observe unexpected behavior. Please provide a concise description of the problem and complement it with code snippets, test cases, screenshots, tracebacks or any other information that you consider relevant. This will help us to replicate the problem and narrow the search space for solutions.","category":"page"},{"location":"contributing.html#Suggesting-features-1","page":"Contributing","title":"Suggesting features","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We welcome new feature proposals. However, before submitting a feature request, consider a few things:","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"Does the feature require changes in the core Rx.jl code? If it doesn't (for example, you would like to add a operator for a particular application), consider making a separate repository for your extensions.\nIf you would like to add an implementation of a feature that changes a lot in the core Rx.jl code, please open an issue on GitHub and describe your proposal first. This will allow us to discuss your proposal with you before you invest your time in implementing something that may be difficult to merge later on.","category":"page"},{"location":"contributing.html#Contributing-code-1","page":"Contributing","title":"Contributing code","text":"","category":"section"},{"location":"contributing.html#Installing-Rx-1","page":"Contributing","title":"Installing Rx","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We suggest that you use the dev command from the new Julia package manager to install Rx.jl for development purposes. To work on your fork of Rx.jl, use your fork's URL address in the dev command, for example:","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"] dev git@github.com:your_username/Rx.jl.git","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"The dev command clones Rx.jl to ~/.julia/dev/Rx. All local changes to Rx code will be reflected in imported code.","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"note: Note\nIt is also might be useful to install Revise.jl package as it allows you to modify code and use the changes without restarting Julia.","category":"page"},{"location":"contributing.html#Committing-code-1","page":"Contributing","title":"Committing code","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We use the standard GitHub Flow workflow where all contributions are added through pull requests. In order to contribute, first fork the repository, then commit your contributions to your fork, and then create a pull request on the master branch of the Rx.jl repository.","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"Before opening a pull request, please make sure that all tests pass without failing! All demos (can be found in /demo/ directory) have to run without errors as well.","category":"page"},{"location":"contributing.html#Style-conventions-1","page":"Contributing","title":"Style conventions","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We use default Julia style guide. We list here a few important points and our modifications to the Julia style guide:","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"Use 4 spaces for indentation\nType names use UpperCamelCase. For example: ArrayObservable, MapOperator, etc..\nFunction names are lowercase with underscores, when necessary. For example: next!, subscribe!, as_actor, etc..\nVariable names and function arguments use snake_case\nThe name of a method that modifies its argument(s) must end in !","category":"page"},{"location":"contributing.html#Unit-tests-1","page":"Contributing","title":"Unit tests","text":"","category":"section"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"We use the test-driven development (TDD) methodology for Rx.jl development. The test coverage should be as complete as possible. Please make sure that you write tests for each piece of code that you want to add.","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"All unit tests are located in the /test/ directory. The /test/ directory follows the structure of the /src/ directory. Each test file should have following filename format: test_*.jl. Some tests are also present in jldoctest docs annotations directly in the source code. See Julia's documentation about doctests. ","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"The tests can be evaluated by running following command in the Julia REPL:","category":"page"},{"location":"contributing.html#","page":"Contributing","title":"Contributing","text":"] test Rx","category":"page"},{"location":"operators/errors/rerun.html#operator_rerun-1","page":"rerun","title":"Rerun Operator","text":"","category":"section"},{"location":"operators/errors/rerun.html#","page":"rerun","title":"rerun","text":"rerun","category":"page"},{"location":"operators/errors/rerun.html#Rx.rerun","page":"rerun","title":"Rx.rerun","text":"rerun(count::Int = -1)\n\nReturns an Observable that mirrors the source Observable with the exception of an error. If the source Observable calls error, this method will resubscribe to the source Observable for a maximum of count resubscriptions (given as a number parameter) rather than propagating the error call.\n\nArguments:\n\ncount::Int: Number of retry attempts before failing. Optional. Default is -1.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from(1:3) |> safe() |> map(Int, (d) -> d > 1 ? error(\"Error\") : d) |> rerun(3)\n\nsubscribe!(source, logger())\n;\n\n# output\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Data: 1\n[LogActor] Error: ErrorException(\"Error\")\n\nSee also: AbstractOperator, InferableOperator, catch_error, logger, safe\n\n\n\n\n\n","category":"function"},{"location":"operators/errors/rerun.html#Description-1","page":"rerun","title":"Description","text":"","category":"section"},{"location":"operators/errors/rerun.html#","page":"rerun","title":"rerun","text":"Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications would be: [1, 2, 1, 2, 3, 4, 5, complete].","category":"page"},{"location":"operators/errors/rerun.html#See-also-1","page":"rerun","title":"See also","text":"","category":"section"},{"location":"operators/errors/rerun.html#","page":"rerun","title":"rerun","text":"Operators","category":"page"},{"location":"observables/types/timer.html#observable_timer-1","page":"Timer","title":"Timer Observable","text":"","category":"section"},{"location":"observables/types/timer.html#","page":"Timer","title":"Timer","text":"timer","category":"page"},{"location":"observables/types/timer.html#Rx.timer","page":"Timer","title":"Rx.timer","text":"timer(due_time::Int = 0, period = nothing)\n\nCreation operator for the TimerObservable. Its like interval(@ref), but you can specify when should the emissions start. timer returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time, period of your choosing between those emissions. The first emission happens after the specified due_time. If period is not specified, the output Observable emits only one value, 0. Otherwise, it emits an infinite sequence.\n\nArguments\n\ndue_time: the initial delay time specified as an integer denoting milliseconds to wait before emitting the first value of 0.\nperiod: the period of time between emissions of the subsequent numbers.\n\nExamples\n\nusing Rx\n\nsource = timer(0, 50)\n\nsleep(0.075)\nsubscription = subscribe!(source, logger())\nsleep(0.105)\nunsubscribe!(subscription)\n\nclose(source)\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Data: 3\n\n\nSee also: interval, TimerObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/timer.html#","page":"Timer","title":"Timer","text":"TimerObservable","category":"page"},{"location":"observables/types/timer.html#Rx.TimerObservable","page":"Timer","title":"Rx.TimerObservable","text":"TimerObservable(due_time::Int, period::Union{Int, Nothing} = nothing)\n\nAn Observable that starts emitting after an dueTime and emits ever increasing numbers after each period of time thereafter.\n\nFields\n\ndue_time: The initial delay time specified as an integer denoting milliseconds to wait before emitting the first value of 0`.\nperiod: The period of time in milliseconds between emissions of the subsequent numbers.\n\nSee also: timer, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"actors/about.html#section_actors-1","page":"Actor","title":"Actors","text":"","category":"section"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"An Actor is the most primitive unit of computation: it receives a message and performs a computation.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"An actor is analogous to an object in an object-oriented languages. An object receives a message (a method call) and does something depending on which message it receives (the method we are calling). The main difference is that actors are completely isolated from each other, and they will never share memory. It’s also worth mentioning that an actor can maintain a private state that should never be changed directly by another actor.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"For a quick introduction to Actor models, see this article.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"The API of Rx.jl's Actors is similar to RxJS subscribers.","category":"page"},{"location":"actors/about.html#First-example-1","page":"Actor","title":"First example","text":"","category":"section"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"The following example implements an Actor that retains each received value from an Observable.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"using Rx\n\nstruct CustomKeepActor <: Actor{Int}\n    values::Vector{Int}\n\n    CustomKeepActor() = new(Vector{Int}())\nend\n\nRx.on_next!(actor::CustomKeepActor, data::Int) = push!(actor.values, data)\nRx.on_error!(actor::CustomKeepActor, err)      = error(err)\nRx.on_complete!(actor::CustomKeepActor)        = println(\"Completed!\")\n\nsource     = from([ 1, 2, 3 ])\nkeep_actor = CustomKeepActor()\nsubscribe!(source, keep_actor)\n\n# Logs\n# Completed!\n\nprintln(keep_actor.values)\n\n# Logs\n# [1, 2, 3]","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"An actor may be not interested in the values itself, but merely the completion of an event. In this case, Rx.jl provides a CompletionActor abstract type.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"using Rx\n\nstruct CompletionNotificationActor <: CompletionActor{Int} end\n\nRx.on_complete!(::CompletionNotificationActor) = println(\"Completed!\")\n\nsource     = from([ 1, 2, 3 ])\nsubscribe!(source, CompletionNotificationActor());\n\n# Logs\n# Completed","category":"page"},{"location":"actors/about.html#Lambda-actor-1","page":"Actor","title":"Lambda actor","text":"","category":"section"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"For debugging purposes it may be convenient to work with a LambdaActor. This provides an interface that defines callbacks for \"next\", \"error\" and \"complete\" events.","category":"page"},{"location":"actors/about.html#","page":"Actor","title":"Actor","text":"using Rx\n\nsource = from([1, 2, 3])\n\nsubscribe!(source, lambda(\n    on_next     = (d) -> println(d),\n    on_error    = (e) -> error(e),\n    on_complete = ()  -> println(\"Completed\")\n))\n\n# Logs\n# 1\n# 2\n# 3\n# Completed","category":"page"},{"location":"observables/types/single.html#observable_single-1","page":"Single","title":"Single Observable","text":"","category":"section"},{"location":"observables/types/single.html#","page":"Single","title":"Single","text":"of","category":"page"},{"location":"observables/types/single.html#Rx.of","page":"Single","title":"Rx.of","text":"of(x)\n\nCreation operator for the SingleObservable that emits a single value x and then completes.\n\nArguments\n\nx: value to be emmited before completion\n\nExamples\n\nusing Rx\n\nsource = of(1)\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\n\nSee also: SingleObservable, subscribe!, logger\n\n\n\n\n\n","category":"function"},{"location":"observables/types/single.html#","page":"Single","title":"Single","text":"SingleObservable","category":"page"},{"location":"observables/types/single.html#Rx.SingleObservable","page":"Single","title":"Rx.SingleObservable","text":"SingleObservable{D}(value::D)\n\nSingleObservable wraps single value of type D into a synchronous observable\n\nSee also: of, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"observables/types/interval.html#observable_interval-1","page":"Interval","title":"Interval Observable","text":"","category":"section"},{"location":"observables/types/interval.html#","page":"Interval","title":"Interval","text":"interval","category":"page"},{"location":"observables/types/interval.html#Rx.interval","page":"Interval","title":"Rx.interval","text":"interval(period::Union{Int, Nothing} = nothing)\n\nCreation operator for the TimerObservable. interval returns an Observable that emits an infinite sequence of ascending integers, with a constant interval of time of your choosing between those emissions. The first emission is not sent immediately, but only after the first period has passed.\n\nArguments\n\ninterval: the interval size in milliseconds\n\nExamples\n\nusing Rx\n\nsource = interval(50)\n\nsubscription = subscribe!(source, LoggerActor{Int}())\nsleep(0.215)\nunsubscribe!(subscription)\nsleep(0.215)\nsubscription = subscribe!(source, LoggerActor{Int}())\nsleep(0.185)\nunsubscribe!(subscription)\n\nclose(source)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Data: 8\n[LogActor] Data: 9\n[LogActor] Data: 10\n\n\nSee also: timer, TimerObservable, Subscribable\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share.html#operator_share-1","page":"share","title":"Share Operators","text":"","category":"section"},{"location":"operators/multicasting/share.html#","page":"share","title":"share","text":"share\nshare_replay","category":"page"},{"location":"operators/multicasting/share.html#Rx.share","page":"share","title":"Rx.share","text":"share(; mode::Val{M} = DEFAULT_SUBJECT_MODE) where M\n\nshare() is a shortcut for publish() + ref_count()\n\nSee also: AbstractOperator, multicast, publish, ref_count\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share.html#Rx.share_replay","page":"share","title":"Rx.share_replay","text":"share_replay(count; mode::Val{M} = DEFAULT_SUBJECT_MODE) where M\n\nshare_replay(count) is a shortcut for publish_replay(count) + ref_count()\n\nSee also: AbstractOperator, multicast, publish, publish_replay, ref_count\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/share.html#See-also-1","page":"share","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/share.html#","page":"share","title":"share","text":"Operators","category":"page"},{"location":"actors/types/async.html#actor_async-1","page":"Async","title":"Async actor","text":"","category":"section"},{"location":"actors/types/async.html#","page":"Async","title":"Async","text":"async","category":"page"},{"location":"actors/types/async.html#Rx.async","page":"Async","title":"Rx.async","text":"async(actor::A) where A\n\nCreation operator for the AsyncActor actor.\n\nExamples\n\nusing Rx\n\nactor = async(keep(Int))\nactor isa AsyncActor{Int, KeepActor{Int}}\n\n# output\ntrue\n\nSee also: AsyncActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/async.html#","page":"Async","title":"Async","text":"AsyncActor","category":"page"},{"location":"actors/types/async.html#Rx.AsyncActor","page":"Async","title":"Rx.AsyncActor","text":"AsyncActor{D, A}(actor::A) where D where A\n\nAsyncActor wraps an actor and send a data from a stream to this actor asynchronously in a different Task. You have to close this actor when you do not need it.\n\nConstructor arguments\n\nactor: any actor to be wrapped\n\nSee also: Actor, async\n\n\n\n\n\n","category":"type"},{"location":"operators/filtering/filter.html#operator_filter-1","page":"filter","title":"Filter Operator","text":"","category":"section"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"filter","category":"page"},{"location":"operators/filtering/filter.html#Base.filter","page":"filter","title":"Base.filter","text":"filter(filterFn::Function)\n\nCreates a filter operator, which filters items by the source Observable by emitting only those that satisfy a specified filterFn predicate.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nArguments\n\nfilterFn::Function: predicate function with (data::T) -> Bool signature\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> filter((d) -> d % 2 == 0), logger())\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/filter.html#Description-1","page":"filter","title":"Description","text":"","category":"section"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"Like filter(f, array), this operator takes values from the source Observable, passes them through a predicate function and only emits those values that yielded true.","category":"page"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"tip: Performance tip\nFor performance reasons, do not use lambda-based operators in production Julia code. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() or @CreateFilterOperator(), etc..), or implement custom operators without using lambda functions.","category":"page"},{"location":"operators/filtering/filter.html#@CreateFilterOperator-macro-1","page":"filter","title":"@CreateFilterOperator macro","text":"","category":"section"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"For performance reasons, the Rx.jl library provides a special macro for creating custom (and pure) filter operators.","category":"page"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"@CreateFilterOperator","category":"page"},{"location":"operators/filtering/filter.html#Rx.@CreateFilterOperator","page":"filter","title":"Rx.@CreateFilterOperator","text":"@CreateFilterOperator(name, L, filterFn)\n\nCreates a custom filter operator, which can be used as nameFilterOperator().\n\nArguments\n\nname: custom operator name\nL: type of data of input source\nfilterFn: predicate function, assumed to be pure\n\nGenerates\n\nnameFilterOperator() function\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\n@CreateFilterOperator(EvenInt, Int, (d) -> d % 2 == 0)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> EvenIntFilterOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nSee also: AbstractOperator, TypedOperator, ProxyObservable, filter, logger\n\n\n\n\n\n","category":"macro"},{"location":"operators/filtering/filter.html#See-also-1","page":"filter","title":"See also","text":"","category":"section"},{"location":"operators/filtering/filter.html#","page":"filter","title":"filter","text":"Operators","category":"page"},{"location":"subjects/types/behavior.html#subject_behavior-1","page":"Behavior","title":"BehaviorSubject","text":"","category":"section"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"make_behavior_subject","category":"page"},{"location":"subjects/types/behavior.html#Rx.make_behavior_subject","page":"Behavior","title":"Rx.make_behavior_subject","text":"make_behavior_subject(::Type{T}, current::T; mode::Val{M} = DEFAULT_SUBJECT_MODE) where T where M\n\nCreation operator for the BehaviorSubject\n\nSee also: BehaviorSubject, make_subject\n\n\n\n\n\n","category":"function"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"BehaviorSubject","category":"page"},{"location":"subjects/types/behavior.html#Rx.BehaviorSubject","page":"Behavior","title":"Rx.BehaviorSubject","text":"BehaviorSubject{D, S}(current, subject)\n\nA variant of Subject that requires an initial value and emits its current value whenever it is subscribed to.\n\nArguments\n\ncurrent: Default current value\nsubject: Subject base type\n\nSee also: make_behavior_subject, make_subject\n\n\n\n\n\n","category":"type"},{"location":"subjects/types/behavior.html#Description-1","page":"Behavior","title":"Description","text":"","category":"section"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"One of the variants of Subjects is the BehaviorSubject, which has a notion of \"the current value\". It stores the latest value emitted to its consumers, and whenever a new Observer subscribes, it will immediately receive the \"current value\" from the BehaviorSubject.","category":"page"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"note: Note\nBehaviorSubjects are useful for representing \"values over time\". For instance, an event stream of birthdays is a Subject, but the stream of a person's age would be a BehaviorSubject.","category":"page"},{"location":"subjects/types/behavior.html#Examples-1","page":"Behavior","title":"Examples","text":"","category":"section"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"In the following example, the BehaviorSubject is initialized with the value 0 which the first Observer receives when it subscribes. The second Observer receives the value 2 even though it subscribed after the value 2 was sent.","category":"page"},{"location":"subjects/types/behavior.html#","page":"Behavior","title":"Behavior","text":"using Rx\n\nsubject = make_behavior_subject(Int, 0)\n\nsubscription1 = subscribe!(subject, logger(\"1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\n\nsubscription2 = subscribe!(subject, logger(\"2\"))\n\nnext!(subject, 3)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n\n// Logs\n// [1] Data: 0\n// [1] Data: 1\n// [1] Data: 2\n// [2] Data: 2\n// [1] Data: 3\n// [2] Data: 3","category":"page"},{"location":"api/operators.html#operators_api-1","page":"Operators","title":"Operators API","text":"","category":"section"},{"location":"api/operators.html#How-to-create-a-custom-operator-1","page":"Operators","title":"How to create a custom operator","text":"","category":"section"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"If you need to write an operator that cannot be made from a combination of existing operators, then you can write a custom operator from scratch.","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"Each operator (e.g. MyFancyOperator) needs to either be (1) a subtype of one of abstract OperatorTrait trait types, or (2) define a","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"Rx.as_operator(::Type{<:MyFancyOperator}) = TypedOperatorTrait{T, R}()\n# or\nRx.as_operator(::Type{<:MyFancyOperator}) = InferableOperatorTrait()","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"trait behavior.","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"In addition, an operator must implement a specific method for on_call! function with custom logic which has to return another Observable as a result of applying MyFancyOperator to a source.","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"Rx.on_call!(::Type{L}, ::Type{R}, operator::MyFancyOperator, source) where L = # some custom logic here\n\n# or\n# for inferable trait types you have to specify 'right' type with Rx.operator_right which should specify a type of data of produced Observable\n\nRx.on_call(::Type{L}, ::Type{R}, operator::MyFancyOperator, source) where L = # some custom logic here\nRx.operator_right(::MyFancyOperator, ::Type{L}) where L = R # where R should be an actual type, Int or even L itself e.g.\n","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"note: Note\nIt is not allowed to modify the source Observable in any way; you have to return a new observable.","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"See more examples on custom operators in Traits API section","category":"page"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"note: Note\nIt might be useful to return a ProxyObservable from an on_call! function. ProxyObservable is a special Observable which proxying actors with the source and/or source with actors.","category":"page"},{"location":"api/operators.html#operators_api_traits-1","page":"Operators","title":"Traits","text":"","category":"section"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"OperatorTrait\nas_operator\nTypedOperatorTrait\nLeftTypedOperatorTrait\nRightTypedOperatorTrait\nInferableOperatorTrait\nInvalidOperatorTrait","category":"page"},{"location":"api/operators.html#Rx.OperatorTrait","page":"Operators","title":"Rx.OperatorTrait","text":"Abstract type for all possible operator traits\n\nSee also: TypedOperatorTrait, LeftTypedOperatorTrait, RightTypedOperatorTrait, InferableOperatorTrait, InvalidOperatorTrait,\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.as_operator","page":"Operators","title":"Rx.as_operator","text":"as_operator(::Type)\n\nThis function checks operator trait behavior. May be used explicitly to specify operator trait behavior for any object.\n\nSee also: OperatorTrait, AbstractOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators.html#Rx.TypedOperatorTrait","page":"Operators","title":"Rx.TypedOperatorTrait","text":"Typed operator trait specifies operator to be statically typed with input and output data types. Typed operator with input type L and output type R can only operate on input Observable with data type L and will always produce an Observable with data type R.\n\nExamples\n\nusing Rx\n\nstruct MyTypedOperator <: TypedOperator{Int, Int} end\n\nfunction Rx.on_call!(::Type{Int}, ::Type{Int}, op::MyTypedOperator, source)\n    return proxy(Int, source, MyTypedOperatorProxy())\nend\n\nstruct MyTypedOperatorProxy <: ActorProxy end\n\nRx.actor_proxy!(::MyTypedOperatorProxy, actor::A) where A = MyTypedOperatorProxiedActor{A}(actor)\n\nstruct MyTypedOperatorProxiedActor{A} <: Actor{Int}\n    actor :: A\nend\n\nfunction Rx.on_next!(actor::MyTypedOperatorProxiedActor, data::Int)\n    # Do something with a data and/or redirect it to actor.actor\n    next!(actor.actor, data + 1)\nend\n\nRx.on_error!(actor::MyTypedOperatorProxiedActor, err) = error!(actor.actor, err)\nRx.on_complete!(actor::MyTypedOperatorProxiedActor)   = complete!(actor.actor)\n\nsource = from([ 0, 1, 2 ])\nsubscribe!(source |> MyTypedOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nSee also: TypedOperator, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.LeftTypedOperatorTrait","page":"Operators","title":"Rx.LeftTypedOperatorTrait","text":"Left typed operator trait specifies operator to be statically typed with input data type. To infer output data type this object should specify a special function operator_right(operator, ::Type{L}) where L which will be used to infer output data type. Left typed operator with input type L can only operate on input Observable with data type L and will always produce an Observable with data type inferred from operator_right(operator, ::Type{L}).\n\nExamples\n\nusing Rx\n\nstruct CountIntegersOperator <: LeftTypedOperator{Int} end\n\nfunction Rx.on_call!(::Type{Int}, ::Type{Tuple{Int, Int}}, op::CountIntegersOperator, source)\n    return proxy(Tuple{Int, Int}, source, CountIntegersOperatorProxy())\nend\n\nRx.operator_right(::CountIntegersOperator, ::Type{Int}) = Tuple{Int, Int}\n\nstruct CountIntegersOperatorProxy <: ActorProxy end\n\nRx.actor_proxy!(::CountIntegersOperatorProxy, actor::A) where A = CountIntegersProxiedActor{A}(0, actor)\n\nmutable struct CountIntegersProxiedActor{A} <: Actor{Int}\n    current :: Int\n    actor   :: A\nend\n\nfunction Rx.on_next!(actor::CountIntegersProxiedActor, data::Int)\n    current = actor.current\n    actor.current += 1\n    next!(actor.actor, (current, data)) # e.g.\nend\n\nRx.on_error!(actor::CountIntegersProxiedActor, err) = error!(actor.actor, err)\nRx.on_complete!(actor::CountIntegersProxiedActor)   = complete!(actor.actor)\n\nsource = from([ 0, 0, 0 ])\nsubscribe!(source |> CountIntegersOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: (0, 0)\n[LogActor] Data: (1, 0)\n[LogActor] Data: (2, 0)\n[LogActor] Completed\n\nSee also: LeftTypedOperator, operator_right, OperatorTrait, ProxyObservable, ActorProxy, enumerate, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.RightTypedOperatorTrait","page":"Operators","title":"Rx.RightTypedOperatorTrait","text":"Right typed operator trait specifies operator to be statically typed with output data type. It can operate on input Observable with any data type L but will always produce an Observable with data type R.\n\nExamples\n\nusing Rx\n\nstruct ConvertToFloatOperator <: RightTypedOperator{Float64} end\n\nfunction Rx.on_call!(::Type{L}, ::Type{Float64}, op::ConvertToFloatOperator, source) where L\n    return proxy(Float64, source, ConvertToFloatProxy{L}())\nend\n\nstruct ConvertToFloatProxy{L} <: ActorProxy end\n\nfunction Rx.actor_proxy!(proxy::ConvertToFloatProxy{L}, actor::A) where L where A\n    return ConvertToFloatProxyActor{L, A}(actor)\nend\n\nmutable struct ConvertToFloatProxyActor{L, A} <: Actor{L}\n    actor :: A\nend\n\nfunction Rx.on_next!(actor::ConvertToFloatProxyActor{L}, data::L) where L\n    next!(actor.actor, convert(Float64, data)) # e.g.\nend\n\nRx.on_error!(actor::ConvertToFloatProxyActor, err) = error!(actor.actor, err)\nRx.on_complete!(actor::ConvertToFloatProxyActor)   = complete!(actor.actor)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> ConvertToFloatOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1.0\n[LogActor] Data: 2.0\n[LogActor] Data: 3.0\n[LogActor] Completed\n\nSee also: RightTypedOperator, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.InferableOperatorTrait","page":"Operators","title":"Rx.InferableOperatorTrait","text":"Inferable operator trait specifies operator to be statically typed neither with input data type nor with output data type. To infer output data type this object should specify a special function operator_right(operator, ::Type{L}) where L where L is input data type which will be used to infer output data type.\n\nusing Rx\n\nstruct IdentityOperator <: InferableOperator end\n\nfunction Rx.on_call!(::Type{L}, ::Type{L}, op::IdentityOperator, source) where L\n    return proxy(L, source, IdentityProxy{L}())\nend\n\nRx.operator_right(::IdentityOperator, ::Type{L}) where L = L\n\nstruct IdentityProxy{L} <: ActorProxy end\n\nRx.actor_proxy!(proxy::IdentityProxy{L}, actor::A) where L where A = IdentityProxyActor{L, A}(actor)\n\nmutable struct IdentityProxyActor{L, A} <: Actor{L}\n    actor :: A\nend\n\nfunction Rx.on_next!(actor::IdentityProxyActor{L}, data::L) where L\n    next!(actor.actor, data) # e.g.\nend\n\nRx.on_error!(actor::IdentityProxyActor, err) = error!(actor.actor, err)\nRx.on_complete!(actor::IdentityProxyActor)   = complete!(actor.actor)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> IdentityOperator(), logger())\n\nsource = from([ 1.0, 2.0, 3.0 ])\nsubscribe!(source |> IdentityOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n[LogActor] Data: 1.0\n[LogActor] Data: 2.0\n[LogActor] Data: 3.0\n[LogActor] Completed\n\n\nSee also: InferableOperator, operator_right, OperatorTrait, ProxyObservable, ActorProxy, logger\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.InvalidOperatorTrait","page":"Operators","title":"Rx.InvalidOperatorTrait","text":"InvalidOperatorTrait trait specifies special 'invalid' behavior and types with such a trait specification cannot be used as an operator for an observable stream. By default any type has InvalidOperatorTrait trait specification\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Types-1","page":"Operators","title":"Types","text":"","category":"section"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"AbstractOperator\nTypedOperator\nLeftTypedOperator\nRightTypedOperator\nInferableOperator\non_call!\noperator_right\nOperatorsComposition","category":"page"},{"location":"api/operators.html#Rx.AbstractOperator","page":"Operators","title":"Rx.AbstractOperator","text":"Supertype for all operators\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.TypedOperator","page":"Operators","title":"Rx.TypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies TypedOperatorTrait behavior.\n\nExamples\n\nusing Rx\n\nstruct MyOperator <: TypedOperator{Int, String} end\n\nprintln(as_operator(MyOperator) === TypedOperatorTrait{Int, String}())\n;\n\n# output\ntrue\n\nSee also: TypedOperatorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.LeftTypedOperator","page":"Operators","title":"Rx.LeftTypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies LeftTypedOperatorTrait behavior.\n\nExamples\n\nusing Rx\n\nstruct MyOperator <: LeftTypedOperator{Int} end\n\nprintln(as_operator(MyOperator) === LeftTypedOperatorTrait{Int}())\n;\n\n# output\ntrue\n\nSee also: LeftTypedOperatorTrait, operator_right\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.RightTypedOperator","page":"Operators","title":"Rx.RightTypedOperator","text":"Can be used as a supertype for any operator. Automatically specifies RightTypedOperatorTrait behavior.\n\nExamples\n\nusing Rx\n\nstruct MyOperator <: RightTypedOperator{Int} end\n\nprintln(as_operator(MyOperator) === RightTypedOperatorTrait{Int}())\n;\n\n# output\ntrue\n\nSee also: RightTypedOperatorTrait\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.InferableOperator","page":"Operators","title":"Rx.InferableOperator","text":"Can be used as a supertype for any operator. Automatically specifies InferableOperatorTrait behavior.\n\nExamples\n\nusing Rx\n\nstruct MyOperator <: InferableOperator end\n\nprintln(as_operator(MyOperator) === InferableOperatorTrait())\n;\n\n# output\ntrue\n\nSee also: InferableOperatorTrait, operator_right\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.on_call!","page":"Operators","title":"Rx.on_call!","text":"on_call!(::Type, ::Type, operator, source)\n\nEach operator must implement its own method for on_call! function. This function is used to invoke operator on some Observable and to produce another Observable with new logic (operator specific).\n\nSee also: AbstractOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators.html#Rx.operator_right","page":"Operators","title":"Rx.operator_right","text":"operator_right(operator, L)\n\nBoth LeftTypedOperator and InferableOperator must implement its own method for operator_right function. This function is used to infer type of data of output Observable given the type of data of input Observable.\n\nSee also: AbstractOperator, LeftTypedOperator, InferableOperator\n\n\n\n\n\n","category":"function"},{"location":"api/operators.html#Rx.OperatorsComposition","page":"Operators","title":"Rx.OperatorsComposition","text":"OperatorsComposition(operators)\n\nOperatorsComposition is an object which helps to create a composition of multiple operators. To create a composition of two or more operators overloaded + can be used.\n\nusing Rx\n\ncomposition = map(Int, (d) -> d ^ 2) + filter(d -> d % 2 == 0)\n\nsource = from(1:5) |> composition\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 4\n[LogActor] Data: 16\n[LogActor] Completed\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Errors-1","page":"Operators","title":"Errors","text":"","category":"section"},{"location":"api/operators.html#","page":"Operators","title":"Operators","text":"InvalidOperatorTraitUsageError\nInconsistentSourceOperatorDataTypesError\nMissingOnCallImplementationError\nMissingOperatorRightImplementationError","category":"page"},{"location":"api/operators.html#Rx.InvalidOperatorTraitUsageError","page":"Operators","title":"Rx.InvalidOperatorTraitUsageError","text":"This error will be thrown if |> pipe operator is called with invalid operator object\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.InconsistentSourceOperatorDataTypesError","page":"Operators","title":"Rx.InconsistentSourceOperatorDataTypesError","text":"This error will be thrown if |> pipe operator is called with inconsistent data type\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.MissingOnCallImplementationError","page":"Operators","title":"Rx.MissingOnCallImplementationError","text":"This error will be thrown if Julia cannot find specific method of on_call! function for a given operator.\n\nSee also: on_call!\n\n\n\n\n\n","category":"type"},{"location":"api/operators.html#Rx.MissingOperatorRightImplementationError","page":"Operators","title":"Rx.MissingOperatorRightImplementationError","text":"This error will be thrown if Julia cannot find specific method of operator_right function for a given operator.\n\nSee also: operator_right\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/map.html#operator_map-1","page":"map","title":"Map Operator","text":"","category":"section"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"map","category":"page"},{"location":"operators/transformation/map.html#Base.map","page":"map","title":"Base.map","text":"map(::Type{R}, mappingFn::Function) where R\n\nCreates a map operator, which applies a given mappingFn to each value emmited by the source Observable, and emits the resulting values as an Observable. You have to specify output R type after mappingFn projection.\n\nArguments\n\n::Type{R}: the type of data of transformed value, may be or may not be the same as source type\nmappingFn::Function: transformation function with (data::L) -> R signature, where L is type of data in input source\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> map(Int, (d) -> d ^ 2), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 4\n[LogActor] Data: 9\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/map.html#Description-1","page":"map","title":"Description","text":"","category":"section"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"Like map(f, array), the map operator applies a function to each source value.","category":"page"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"tip: Performance tip\nFor performance reasons, do not use lambda based operators in production Julia code. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() and/or @CreateFilterOperator(), etc..) or implement your own operators without using lambda functions.","category":"page"},{"location":"operators/transformation/map.html#@CreateMapOperator-macro-1","page":"map","title":"@CreateMapOperator macro","text":"","category":"section"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"For performance reasons Rx.jl library provides a special macro for creating custom (and pure) map operators.","category":"page"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"@CreateMapOperator","category":"page"},{"location":"operators/transformation/map.html#Rx.@CreateMapOperator","page":"map","title":"Rx.@CreateMapOperator","text":"@CreateMapOperator(name, L, R, mappingFn)\n\nCreates a custom map operator, which can be used as nameMapOperator().\n\nArguments\n\nname: custom operator name\nL: type of input data\nR: type of output data after mappingFn projection\nmappingFn: transformation function, assumed to be pure\n\nGenerates\n\nnameMapOperator() function\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\n@CreateMapOperator(SquaredInt, Int, Int, (d) -> d ^ 2)\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> SquaredIntMapOperator(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 4\n[LogActor] Data: 9\n[LogActor] Completed\n\n\nSee also: AbstractOperator, TypedOperator,, ProxyObservable, map, logger\n\n\n\n\n\n","category":"macro"},{"location":"operators/transformation/map.html#See-also-1","page":"map","title":"See also","text":"","category":"section"},{"location":"operators/transformation/map.html#","page":"map","title":"map","text":"Operators","category":"page"},{"location":"operators/multicasting/multicast.html#operator_multicast-1","page":"multicast","title":"Multicast Operator","text":"","category":"section"},{"location":"operators/multicasting/multicast.html#","page":"multicast","title":"multicast","text":"multicast","category":"page"},{"location":"operators/multicasting/multicast.html#Rx.multicast","page":"multicast","title":"Rx.multicast","text":"multicast(subject::S) where S\nmulticast(factory::F) where { F <: AbstractSubjectFactory }\n\nThe multicast()operator takes a Subject and uses it to share the source execution. It returns what’s known as aConnectableObservable`, which has a connect() method. It has one simple job - subscribes to the source with the provided subject.\n\nExample\n\nusing Rx\n\nsubject = make_subject(Int, mode = SYNCHRONOUS_SUBJECT_MODE)\nsource  = from(1:5) |> multicast(subject)\n\nactor1 = logger(\"1\")\nactor2 = logger(\"2\")\n\nsubscription1 = subscribe!(source, actor1)\nsubscription2 = subscribe!(source, actor2)\n\nconnect(source)\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n;\n\n# output\n\n[1] Data: 1\n[2] Data: 1\n[1] Data: 2\n[2] Data: 2\n[1] Data: 3\n[2] Data: 3\n[1] Data: 4\n[2] Data: 4\n[1] Data: 5\n[2] Data: 5\n[1] Completed\n[2] Completed\n\nSee also: ConnectableObservable, make_subject, share, publish\n\n\n\n\n\n","category":"function"},{"location":"operators/multicasting/multicast.html#See-also-1","page":"multicast","title":"See also","text":"","category":"section"},{"location":"operators/multicasting/multicast.html#","page":"multicast","title":"multicast","text":"Operators","category":"page"},{"location":"observables/types/combined.html#observable_combined-1","page":"Combined","title":"Combined Observable","text":"","category":"section"},{"location":"observables/types/combined.html#","page":"Combined","title":"Combined","text":"combineLatest","category":"page"},{"location":"observables/types/combined.html#Rx.combineLatest","page":"Combined","title":"Rx.combineLatest","text":"combineLatest(sources...)\n\nCombines multiple Observables to create an Observable whose values are calculated from the latest values of each of its input Observables.\n\nExamples\n\nusing Rx\n\nlatest = combineLatest(of(1), from(2:5))\n\nsubscribe!(latest, logger())\n;\n\n# output\n\n[LogActor] Data: (1, 2)\n[LogActor] Data: (1, 3)\n[LogActor] Data: (1, 4)\n[LogActor] Data: (1, 5)\n[LogActor] Completed\n\nSee also: Subscribable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/combined.html#Description-1","page":"Combined","title":"Description","text":"","category":"section"},{"location":"observables/types/combined.html#","page":"Combined","title":"Combined","text":"combineLatest combines the values from all Observables in its arguments. This is done by subscribing to each Observable in order and, whenever an Observable emits, collecting a tuple of the most recent values from each Observable (in order). If you pass n Observables to combineLatest, the returned Observable will always emit an ordered tuple of n values.","category":"page"},{"location":"observables/types/combined.html#","page":"Combined","title":"Combined","text":"To ensure that the output tuple has a consistent length, combineLatest waits for all input Observables to emit at least once before it starts emitting results. This means that if some Observable emits values before other Observables started emitting, all these values but the last will be lost. On the other hand, if some Observable does not emit a value but completes, the resulting Observable will complete simultaneously without emitting anything. Furthermore, if some input Observable does not emit any value and never completes, combineLatest will also never emit and never complete.","category":"page"},{"location":"observables/types/combined.html#","page":"Combined","title":"Combined","text":"If at least one Observable was passed to combineLatest and all passed Observables emitted, then the resulting Observable will complete when all combined streams complete. So even if some Observable completes, the result of combineLatest will still emit values when the other Observables do. In case of a completed Observable, its value will now remain to be the last emitted value. On the other hand, if any Observable errors, combineLatest will also immediately error.","category":"page"},{"location":"observables/types/combined.html#","page":"Combined","title":"Combined","text":"note: Note\nCurrent Rx.jl implementation uses macro-generated optimized combineLatest structure definitions for up to ten Observables. ","category":"page"},{"location":"operators/filtering/about.html#Filtering-category-1","page":"About filtering operators","title":"Filtering category","text":"","category":"section"},{"location":"operators/filtering/about.html#","page":"About filtering operators","title":"About filtering operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in filtering category.","category":"page"},{"location":"operators/filtering/about.html#","page":"About filtering operators","title":"About filtering operators","text":"filter\ntake\nfirst\nlast","category":"page"},{"location":"operators/filtering/about.html#See-also-1","page":"About filtering operators","title":"See also","text":"","category":"section"},{"location":"operators/filtering/about.html#","page":"About filtering operators","title":"About filtering operators","text":"Operators","category":"page"},{"location":"observables/types/connectable.html#observable_connectable-1","page":"Connectable","title":"Connectable Observable","text":"","category":"section"},{"location":"observables/types/connectable.html#","page":"Connectable","title":"Connectable","text":"connectable","category":"page"},{"location":"observables/types/connectable.html#Rx.connectable","page":"Connectable","title":"Rx.connectable","text":"connectable(subject::J, source::S) where J where S\n\nCreates a ConnectableObservable with a given subject object and a source observable.\n\nExample\n\nusing Rx\n\nc = connectable(make_subject(Int; mode = Val(:sync)), from(1:3))\n\nsubscribe!(c, logger());\n\nconnect(c);\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\n\nSee also: ConnectableObservable, connect, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/connectable.html#","page":"Connectable","title":"Connectable","text":"connect","category":"page"},{"location":"observables/types/connectable.html#Rx.connect","page":"Connectable","title":"Rx.connect","text":"connect(connectable::ConnectableObservable)\n\nWhen connect is called, the subject passed to the multicast operator is subscribed to the source and the subject’s observers receive the multicast notifications, which fits our basic mental model of RxJS multicasting. Returns a subscription.\n\nSee also: connectable, ConnectableObservable\n\n\n\n\n\n","category":"function"},{"location":"observables/types/connectable.html#","page":"Connectable","title":"Connectable","text":"ConnectableObservable","category":"page"},{"location":"observables/types/connectable.html#Rx.ConnectableObservable","page":"Connectable","title":"Rx.ConnectableObservable","text":"ConnectableObservable{D}(subject, source)\n\nA connectable observable encapsulates the multicasting infrastructure with provided subject, but does not immediately subscribe to the source. It subscribes to the source when its connect method is called.\n\nSee also: connect, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"operators/errors/about.html#Error-handling-category-1","page":"About error handling operators","title":"Error handling category","text":"","category":"section"},{"location":"operators/errors/about.html#","page":"About error handling operators","title":"About error handling operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in error handling category.","category":"page"},{"location":"operators/errors/about.html#","page":"About error handling operators","title":"About error handling operators","text":"catch_error\nrerun","category":"page"},{"location":"operators/errors/about.html#See-also-1","page":"About error handling operators","title":"See also","text":"","category":"section"},{"location":"operators/errors/about.html#","page":"About error handling operators","title":"About error handling operators","text":"Operators","category":"page"},{"location":"operators/utility/delay.html#operator_delay-1","page":"delay","title":"Delay Operator","text":"","category":"section"},{"location":"operators/utility/delay.html#","page":"delay","title":"delay","text":"delay","category":"page"},{"location":"operators/utility/delay.html#Rx.delay","page":"delay","title":"Rx.delay","text":"delay(delay::Int)\n\nCreates a delay operators, which delays the emission of items from the source Observable by a given timeout.\n\nArguments:\n\ndelay::Int: the delay duration in milliseconds (a number) until which the emission of the source items is delayed.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/delay.html#Description-1","page":"delay","title":"Description","text":"","category":"section"},{"location":"operators/utility/delay.html#","page":"delay","title":"delay","text":"Delays the emission of items from the source Observable by a given timeout","category":"page"},{"location":"operators/utility/delay.html#Example-1","page":"delay","title":"Example","text":"","category":"section"},{"location":"operators/utility/delay.html#","page":"delay","title":"delay","text":"Delay every value with 1 second to the output","category":"page"},{"location":"operators/utility/delay.html#","page":"delay","title":"delay","text":"using Rx\nusing Dates\n\nsource = from([ 1, 2, 3 ])\nprintln(Dates.format(now(), \"MM:SS\"))\nsubscription = subscribe!(source |> delay(2000), LambdaActor{Int}(\n    on_next = (d) -> println(\"$(Dates.format(now(), \"MM:SS\")): $d\")\n));\n\n# output\n\n03:41\n03:43: 1\n03:43: 2\n03:43: 3\n","category":"page"},{"location":"operators/utility/delay.html#See-also-1","page":"delay","title":"See also","text":"","category":"section"},{"location":"operators/utility/delay.html#","page":"delay","title":"delay","text":"Operators","category":"page"},{"location":"operators/filtering/take.html#operator_take-1","page":"take","title":"Take Operator","text":"","category":"section"},{"location":"operators/filtering/take.html#","page":"take","title":"take","text":"take","category":"page"},{"location":"operators/filtering/take.html#Rx.take","page":"take","title":"Rx.take","text":"take(max_count::Int)\n\nCreates a take operator, which returns an Observable that emits only the first max_count values emitted by the source Observable.\n\nArguments\n\nmax_count::Int: the maximum number of next values to emit.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:100 ])\nactor  = keep(Int)\nsubscription = subscribe!(source |> take(5), actor)\nprintln(actor.values)\n;\n\n# output\n\n[1, 2, 3, 4, 5]\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/take.html#Description-1","page":"take","title":"Description","text":"","category":"section"},{"location":"operators/filtering/take.html#","page":"take","title":"take","text":"take returns an Observable that emits only the first count values emitted by the source Observable. If the source emits fewer than count values, then all of its values are emitted. Afterwards, the Observable completes regardless of whether the source completed.","category":"page"},{"location":"operators/filtering/take.html#See-also-1","page":"take","title":"See also","text":"","category":"section"},{"location":"operators/filtering/take.html#","page":"take","title":"take","text":"Operators","category":"page"},{"location":"operators/transformation/scan.html#operator_scan-1","page":"scan","title":"Scan Operator","text":"","category":"section"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"scan","category":"page"},{"location":"operators/transformation/scan.html#Rx.scan","page":"scan","title":"Rx.scan","text":"scan(::Type{R}, scanFn::Function, seed::Union{R, Nothing} = nothing) where R\n\nCreates a scan operator, which applies a given accumulator scanFn function to each value emmited by the source Observable, and returns each intermediate result with an optional seed value. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.\n\nArguments\n\n::Type{R}: the type of data of transformed value, may be or may not be the same as type of input source\nscanFn::Function: accumulator function with (data::T, current::R) -> R signature\nseed::R: optional initial value for accumulator function\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> scan(Vector{Int}, (d, c) -> [ c..., d ], Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1]\n[LogActor] Data: [1, 2]\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, RightTypedOperator, ProxyObservable, reduce, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/scan.html#Description-1","page":"scan","title":"Description","text":"","category":"section"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"Combines all values emitted by the source, using an accumulator function that joins a new source value with the past accumulation. This is similar to reduce, but emits the intermediate accumulations.","category":"page"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"Returns an Observable that applies a specified accumulator function to each item emitted by the source Observable. If a seed value is specified, then that value will be used as the initial value for the accumulator. If no seed value is specified, the first item of the source is used as the seed.","category":"page"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"tip: Performance tip\nFor performance reasons, do not use lambda based operators in production Julia code. Either use macro helpers to generate efficient versions of operators (like @CreateMapOperator() and/or @CreateFilterOperator(), etc..) or implement your own operators without using lambda functions.","category":"page"},{"location":"operators/transformation/scan.html#@CreateScanOperator-macro-1","page":"scan","title":"@CreateScanOperator macro","text":"","category":"section"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"For performance reasons, the Rx.jl library provides a special macro for creating custom (and pure) scan operators.","category":"page"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"@CreateScanOperator","category":"page"},{"location":"operators/transformation/scan.html#Rx.@CreateScanOperator","page":"scan","title":"Rx.@CreateScanOperator","text":"@CreateScanOperator(name, L, R, scanFn)\n\nCreates a custom scan operator, which can be used as nameScanOperator().\n\nArguments\n\nname: custom operator name\nL: type of input data\nR: type of output data after scanFn projection\nscanFn: accumulator function, assumed to be pure\n\nGenerates\n\nnameScanOperator(seed::R) function\n\nProducing\n\nStream of type <: Subscribable{R}\n\nExamples\n\nusing Rx\n\n@CreateScanOperator(IntoArray, Int, Vector{Int}, (d, c) -> [ c..., d ])\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> IntoArrayScanOperator(Int[]), logger())\n;\n\n# output\n\n[LogActor] Data: [1]\n[LogActor] Data: [1, 2]\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, TypedOperator, ProxyObservable, scan, logger\n\n\n\n\n\n","category":"macro"},{"location":"operators/transformation/scan.html#See-also-1","page":"scan","title":"See also","text":"","category":"section"},{"location":"operators/transformation/scan.html#","page":"scan","title":"scan","text":"Operators","category":"page"},{"location":"operators/creation/about.html#Creation-category-1","page":"Creation","title":"Creation category","text":"","category":"section"},{"location":"operators/creation/about.html#","page":"Creation","title":"Creation","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in creation category.","category":"page"},{"location":"operators/creation/about.html#","page":"Creation","title":"Creation","text":"of\nfrom\nerror\nnever\ncompleted\ntimer\ninterval","category":"page"},{"location":"operators/creation/about.html#See-also-1","page":"Creation","title":"See also","text":"","category":"section"},{"location":"operators/creation/about.html#","page":"Creation","title":"Creation","text":"Operators","category":"page"},{"location":"operators/utility/noop.html#operator_noop-1","page":"noop","title":"Noop Operator","text":"","category":"section"},{"location":"operators/utility/noop.html#","page":"noop","title":"noop","text":"noop","category":"page"},{"location":"operators/utility/noop.html#Rx.noop","page":"noop","title":"Rx.noop","text":"noop()\n\nCreates a noop operator, which does nothing, but breaks operator composition type inference checking procedure for Julia's compiler. It might be useful for very long chain of operators, because Julia tries to statically infer data types at compile-time for the whole chain and can run into StackOverflow issues.\n\nusing Rx\n\nsource = from(1:5)\n\nfor i in 1:1000\n    source = source |> map(Int, d -> d + 1) |> noop()\nend\n\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1001\n[LogActor] Data: 1002\n[LogActor] Data: 1003\n[LogActor] Data: 1004\n[LogActor] Data: 1005\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, logger, map\n\n\n\n\n\n","category":"function"},{"location":"operators/utility/noop.html#See-also-1","page":"noop","title":"See also","text":"","category":"section"},{"location":"operators/utility/noop.html#","page":"noop","title":"noop","text":"Operators","category":"page"},{"location":"getting-started.html#Getting-started-1","page":"Getting started","title":"Getting started","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Rx.jl is a Julia package for reactive programming that makes it easier to work with asynchronous data. It is inspired by the RxJS and ReactiveX communities.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"In order to combine good performance with a convenient API, Rx.jl employs Observer patterns, Actor models and Functional programming.","category":"page"},{"location":"getting-started.html#Installation-1","page":"Getting started","title":"Installation","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Install Rx.jl through the Julia package manager:","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"] add Rx","category":"page"},{"location":"getting-started.html#Concepts-1","page":"Getting started","title":"Concepts","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Rx.jl has been designed with a focus on performance and modularity.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"The essential concepts in Rx.jl are:","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Observable: represents a collection of future messages (data or/and events).\nActor: is an object that knows how to react on incoming messages delivered by the Observable.\nSubscription: represents a teardown logic that is useful for cancelling the execution of an Observable.\nOperator: an object that deals with collection operations, such as map, filter, reduce, etc.\nSubject: the way of multicasting a message to multiple Observers.","category":"page"},{"location":"getting-started.html#First-example-1","page":"Getting started","title":"First example","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Conventionally, arrays are used for processing data.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"for value in array_of_values\n    doSomethingWithMyData(value)\nend","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"In contrast, Rx.jl uses observables.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"subscription = subscribe!(source_of_values, lambda(\n    on_next  = (data)  -> doSomethingWithMyData(data),\n    on_error = (error) -> doSomethingWithAnError(error),\n    complete = ()      -> println(\"Completed! You deserve some coffee man\")\n))","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"At some point in time you may decide to stop listening for new messages.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"unsubscribe!(subscription)","category":"page"},{"location":"getting-started.html#Actors-1","page":"Getting started","title":"Actors","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"In order to process messages from an observable you will need to define an Actor that knows how to react to incoming messages.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"struct MyActor <: Rx.Actor{Int} end\n\nRx.on_next!(actor::MyActor, data::Int) = doSomethingWithMyData(data)\nRx.on_error!(actor::MyActor, error)    = doSomethingWithAnError(error)\nRx.on_complete!(actor::MyActor)        = println(\"Completed!\")","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"An actor can also have its own local state.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"struct StoreActor{D} <: Rx.Actor{}\n    values :: Vector{D}\n\n    StoreActor{D}() where D = new(Vector{D}())\nend\n\nRx.on_next!(actor::StoreActor{D}, data::D) where D = push!(actor.values, data)\nRx.on_error!(actor::StoreActor, error)             = doSomethingWithAnError(error)\nRx.on_complete!(actor::StoreActor)                 = println(\"Completed: $(actor.values)\")","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"For debugging purposes you can use a general LambdaActor actor.","category":"page"},{"location":"getting-started.html#Operators-1","page":"Getting started","title":"Operators","text":"","category":"section"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"What makes Rx.jl powerful is its ability to help you process, transform and modify the messages that flow through your observables, using Operators.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"subscribe!(squared_int_values |> map(Int, (d) -> d ^ 2), LambdaActor{Int}(\n    on_next = (data) -> println(data)\n))","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"You can also use a special macro which is defined for some operators to produce an optimized version of some operations on observables, without using the callbacks.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"@CreateMapOperator(\"SquaredInt\", Int, Int, (d) -> d ^ 2)\nsquared_int_values = source_of_int_values |> SquaredIntMapOperator()","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"Below is a performance comparison between different approaches, with an Observable of 500 integers and a StoreActor.","category":"page"},{"location":"getting-started.html#","page":"Getting started","title":"Getting started","text":"|      | Using regular array | Using macro generated map operator | Using lambda based map operator | |–––|––––––––––-|––––––––––––––––––|––––––––––––––––-| | Time |3.174 μs (9 allocations: 8.33 KiB)|3.489 μs (11 allocations: 8.36 KiB)|25.780 μs (489 allocations: 15.84 KiB)|","category":"page"},{"location":"operators/filtering/first.html#operator_first-1","page":"first","title":"First operator","text":"","category":"section"},{"location":"operators/filtering/first.html#","page":"first","title":"first","text":"first","category":"page"},{"location":"operators/filtering/first.html#Base.first","page":"first","title":"Base.first","text":"first()\n\nCreates a first operator, which returns an Observable that emits only the first value emitted by the source Observable.\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:100 ])\nactor  = keep(Int)\nsubscription = subscribe!(source |> first(), actor)\nprintln(actor.values)\n;\n\n# output\n\n[1]\n\nSee also: take, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/filtering/first.html#Description-1","page":"first","title":"Description","text":"","category":"section"},{"location":"operators/filtering/first.html#","page":"first","title":"first","text":"An alias for take(1) operator.","category":"page"},{"location":"operators/filtering/first.html#See-also-1","page":"first","title":"See also","text":"","category":"section"},{"location":"operators/filtering/first.html#","page":"first","title":"first","text":"Operators, take","category":"page"},{"location":"observables/types/error.html#observable_error-1","page":"Error","title":"Error Observable","text":"","category":"section"},{"location":"observables/types/error.html#","page":"Error","title":"Error","text":"throwError","category":"page"},{"location":"observables/types/error.html#Rx.throwError","page":"Error","title":"Rx.throwError","text":"throwError(error, T = Any)\n\nCreation operator for the ErrorObservable that emits no items to the Actor and immediately sends an error notification.\n\nArguments\n\nerror: the particular Error to pass to the error notification.\nT: type of output data source, optional, Any is the default\n\nExamples\n\nusing Rx\n\nsource = throwError(\"Error!\")\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Error: Error!\n\n\nSee also: ErrorObservable, subscribe!\n\n\n\n\n\n","category":"function"},{"location":"observables/types/error.html#","page":"Error","title":"Error","text":"ErrorObservable","category":"page"},{"location":"observables/types/error.html#Rx.ErrorObservable","page":"Error","title":"Rx.ErrorObservable","text":"ErrorObservable{D}(err)\n\nObservable that emits no items to the Actor and immediately sends an error notification on subscription.\n\nSee also: throwError\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/min.html#operator_min-1","page":"min","title":"Min Operator","text":"","category":"section"},{"location":"operators/mathematical/min.html#","page":"min","title":"min","text":"min","category":"page"},{"location":"operators/mathematical/min.html#Base.min","page":"min","title":"Base.min","text":"min(; from = nothing)\n\nCreates a min operator, which emits a single item: the item with the smallest value.\n\nArguments\n\nfrom: optional initial minimal value, if nothing first item from the source will be used as initial instead\n\nProducing\n\nStream of type <: Subscribable{Union{L, Nothing}} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> min(), logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/min.html#Description-1","page":"min","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/min.html#","page":"min","title":"min","text":"The min operator operates on an Observable of similar objects. When source Observable completes, it emits the item with the smallest value.","category":"page"},{"location":"operators/mathematical/min.html#See-also-1","page":"min","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/min.html#","page":"min","title":"min","text":"Operators","category":"page"},{"location":"subjects/about.html#section_subjects-1","page":"Subject","title":"About subjects","text":"","category":"section"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"An Rx.jl Subject is a special type of Observable that allows values to be multicasted to many Actors. While plain Observables are unicast (each subscribed Actor owns an independent execution of the Observable), Subjects are multicast.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"note: Note\nA Subject is like an Observable, but can multicast to many Actors. Subjects are like event emitters: they maintain a registry of many listeners.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"Every Subject is an Observable. Given a Subject, you can subscribe to it, providing an Actor, which will start receiving values normally. From the perspective of the Actor, it cannot tell whether the Observable execution is coming from a plain unicast Observable or a Subject.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"Internally to the Subject, subscribe does not invoke a new execution that delivers values. Instead, it simply registers the given Actor in a list of Actors.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"Every Subject is an Actor itself. It is an object with the methods next!, error!, and complete!. Call next!(subject, theValue) to feed a new value to the Subject, and it will be multicasted to the Actors that listen to the Subject.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"In the example below, we have two Observers attached to a Subject, and we feed some values to the Subject:","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"using Rx\n\nsource = make_subject(Int)\n\nsubscription1 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 1: $d\")\n))\n\nsubscription2 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 2: $d\")\n))\n\nnext!(source, 0)\n\n# Logs\n# Actor 1: 0\n# Actor 2: 0\n\nunsubscribe!(subscription1)\nunsubscribe!(subscription2)\n","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"Since a Subject is an actor, this also means you may provide a Subject as the argument to the subscribe of any Observable:","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"using Rx\n\nsource = make_subject(Int)\n\nsubscription1 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 1: $d\")\n))\n\nsubscription2 = subscribe!(source, lambda(\n    on_next = (d) -> println(\"Actor 2: $d\")\n))\n\nother_source = from([ 1, 2, 3 ])\nsubscribe!(other_source, source);\n\n# Logs\n# Actor 1: 1\n# Actor 2: 1\n# Actor 1: 2\n# Actor 2: 2\n# Actor 1: 3\n# Actor 2: 3","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"Here, we essentially convert a unicast Observable execution to multicast, through the Subject. This demonstrates how Subjects offer a unique way to share Observable execution with multiple Observers.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"There are a two base-type specializations of the Subject type: AsynchronousSubject, and SynchronousSubject.","category":"page"},{"location":"subjects/about.html#AsynchronousSubject-1","page":"Subject","title":"AsynchronousSubject","text":"","category":"section"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"One of the variants of Subjects is the AsynchronousSubject, which delivers each message to attached listeners asynchronously (but still ordered) using a Julia's built-in Task object.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"AsynchronousSubject","category":"page"},{"location":"subjects/about.html#Rx.AsynchronousSubject","page":"Subject","title":"Rx.AsynchronousSubject","text":"AsynchronousSubject{D}()\n\nAsynchronousSubject is a base-type subject that asynchronously delivers all messages to the attached listeners using a different asynchronous task for each listener.\n\nSee also: as_subject, make_subject\n\n\n\n\n\n","category":"type"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"using Rx\n\nsubject = make_subject(Int, mode = ASYNCHRONOUS_SUBJECT_MODE)\n\nsubscription1 = subscribe!(subject, logger(\"Actor 1\"))\n\nnext!(subject, 1)\nnext!(subject, 2)\nprint\n\nsubscription2 = subscribe!(subject, logger(\"Actor 2\"))\n\nnext!(subject, 3)\n\n# Logs\n# [Actor 1] Data: 1\n# [Actor 1] Data: 2\n# [Actor 1] Data: 3\n# [Actor 2] Data: 3\n","category":"page"},{"location":"subjects/about.html#SynchronousSubject-1","page":"Subject","title":"SynchronousSubject","text":"","category":"section"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"A SynchronousSubject is similar to a AsynchronousSubject. Both multicast values to multiple listeners, but a SynchronousSubject delivers all messages synchronously.","category":"page"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"SynchronousSubject","category":"page"},{"location":"subjects/about.html#Rx.SynchronousSubject","page":"Subject","title":"Rx.SynchronousSubject","text":"SynchronousSubject{D}()\n\nSynchronousSubject is a base-type subject that synchronously delivers all messages to the attached listeners using a simple for-loop.\n\nSee also: as_subject, make_subject\n\n\n\n\n\n","category":"type"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"using Rx\n\nsubject = make_subject(Int, mode = SYNCHRONOUS_SUBJECT_MODE)","category":"page"},{"location":"subjects/about.html#Subject-creation-1","page":"Subject","title":"Subject creation","text":"","category":"section"},{"location":"subjects/about.html#","page":"Subject","title":"Subject","text":"make_subject","category":"page"},{"location":"subjects/about.html#Rx.make_subject","page":"Subject","title":"Rx.make_subject","text":"make_subject(::Type{T}; mode::Val{M} = DEFAULT_SUBJECT_MODE) where T where M\n\nCreation operator for the base-type subject objects. By default AsynchronousSubject{T} is created.\n\nSee also: SynchronousSubject, AsynchronousSubject\n\n\n\n\n\n","category":"function"},{"location":"api/subjects.html#subjects_api-1","page":"Subjects","title":"Subjects API","text":"","category":"section"},{"location":"api/subjects.html#Traits-1","page":"Subjects","title":"Traits","text":"","category":"section"},{"location":"api/subjects.html#","page":"Subjects","title":"Subjects","text":"SubjectTrait\nas_subject  \nValidSubject\nInvalidSubject","category":"page"},{"location":"api/subjects.html#Rx.SubjectTrait","page":"Subjects","title":"Rx.SubjectTrait","text":"Abstract type for all possible subject traits\n\nSee also: ValidSubject, InvalidSubject, as_subject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Rx.as_subject","page":"Subjects","title":"Rx.as_subject","text":"as_subject(::Type)\n\nThis function checks subject trait behavior specification. Should be used explicitly to specify subject trait behavior for any object type.\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"function"},{"location":"api/subjects.html#Rx.ValidSubject","page":"Subjects","title":"Rx.ValidSubject","text":"Valid subject trait behavior\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Rx.InvalidSubject","page":"Subjects","title":"Rx.InvalidSubject","text":"Default subject trait behavior for all types.\n\nSee also: SubjectTrait\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Factory-1","page":"Subjects","title":"Factory","text":"","category":"section"},{"location":"api/subjects.html#","page":"Subjects","title":"Subjects","text":"AbstractSubjectFactory\ncreate_subject\nMissingCreateSubjectFactoryImplementationError","category":"page"},{"location":"api/subjects.html#Rx.AbstractSubjectFactory","page":"Subjects","title":"Rx.AbstractSubjectFactory","text":"Abstract type for all possible subject factories\n\nSee also: SubjectTrait, ValidSubject, InvalidSubject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Rx.create_subject","page":"Subjects","title":"Rx.create_subject","text":"create_subject(::Type{L}, factory::F) where L where { F <: AbstractSubjectFactory }\n\nActor creator function for a given factory F. Should be implemented explicitly for any AbstractActorFactory object\n\nSee also: AbstractSubjectFactory, MissingCreateActorFactoryImplementationError\n\n\n\n\n\n","category":"function"},{"location":"api/subjects.html#Rx.MissingCreateSubjectFactoryImplementationError","page":"Subjects","title":"Rx.MissingCreateSubjectFactoryImplementationError","text":"This error will be throw if Julia cannot find specific method of 'create_subject()' function for given subject factory\n\nSee also: AbstractSubjectFactory, create_subject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Errors-1","page":"Subjects","title":"Errors","text":"","category":"section"},{"location":"api/subjects.html#","page":"Subjects","title":"Subjects","text":"InvalidSubjectTraitUsageError\nInconsistentSubjectDataTypesError","category":"page"},{"location":"api/subjects.html#Rx.InvalidSubjectTraitUsageError","page":"Subjects","title":"Rx.InvalidSubjectTraitUsageError","text":"InvalidSubject usage error\n\nSee also: as_subject\n\n\n\n\n\n","category":"type"},{"location":"api/subjects.html#Rx.InconsistentSubjectDataTypesError","page":"Subjects","title":"Rx.InconsistentSubjectDataTypesError","text":"InconsistentSubjectDataTypesError\n\nSee also: as_subject\n\n\n\n\n\n","category":"type"},{"location":"operators/transformation/lowercase.html#operator_lowercase-1","page":"lowercase","title":"Lowercase Operator","text":"","category":"section"},{"location":"operators/transformation/lowercase.html#","page":"lowercase","title":"lowercase","text":"lowercase","category":"page"},{"location":"operators/transformation/lowercase.html#Base.Unicode.lowercase","page":"lowercase","title":"Base.Unicode.lowercase","text":"lowercase()\n\nCreates an lowercase operator, which forces each value to be in lower case\n\nProducing\n\nStream of type <: Subscribable{L} where L referes to type of data of input Observable\n\nExamples\n\nusing Rx\n\nsource = of(\"Hello, world!\")\nsubscribe!(source |> lowercase(), logger())\n;\n\n# output\n\n[LogActor] Data: hello, world!\n[LogActor] Completed\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/lowercase.html#See-also-1","page":"lowercase","title":"See also","text":"","category":"section"},{"location":"operators/transformation/lowercase.html#","page":"lowercase","title":"lowercase","text":"Operators, map, uppercase","category":"page"},{"location":"teardown/types/void.html#teardown_void-1","page":"Void","title":"Void Teardown","text":"","category":"section"},{"location":"teardown/types/void.html#","page":"Void","title":"Void","text":"VoidTeardown","category":"page"},{"location":"teardown/types/void.html#Rx.VoidTeardown","page":"Void","title":"Rx.VoidTeardown","text":"VoidTeardown()\n\nVoidTeardown object does nothing on unsubscription. It is usefull for synchronous observables.\n\nSee also: Teardown, VoidTeardownLogic\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/about.html#Mathematical-and-Aggregate-category-1","page":"About mathematical operators","title":"Mathematical and Aggregate category","text":"","category":"section"},{"location":"operators/mathematical/about.html#","page":"About mathematical operators","title":"About mathematical operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in mathematical and aggregate category.","category":"page"},{"location":"operators/mathematical/about.html#","page":"About mathematical operators","title":"About mathematical operators","text":"count\nmax\nmin\nreduce\nsum","category":"page"},{"location":"operators/mathematical/about.html#See-also-1","page":"About mathematical operators","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/about.html#","page":"About mathematical operators","title":"About mathematical operators","text":"Operators","category":"page"},{"location":"operators/transformation/enumerate.html#operator_enumerate-1","page":"enumerate","title":"Enumerate Operator","text":"","category":"section"},{"location":"operators/transformation/enumerate.html#","page":"enumerate","title":"enumerate","text":"enumerate","category":"page"},{"location":"operators/transformation/enumerate.html#Base.Iterators.enumerate","page":"enumerate","title":"Base.Iterators.enumerate","text":"enumerate()\n\nCreates an enumerate operator, which converts each value emitted by the source Observable into a tuple of its order number and the value itself.\n\nThe enumerate operator is similar to scan(Tuple{Int, Int}, (d, c) -> (d, c[2] + 1), (0, 0)) (see scan).\n\nProducing\n\nStream of type <: Subscribable{Tuple{L, Int}} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:3 ])\nsubscribe!(source |> enumerate(), logger())\n;\n\n# output\n\n[LogActor] Data: (1, 1)\n[LogActor] Data: (2, 2)\n[LogActor] Data: (3, 3)\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, scan, map, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/enumerate.html#Description-1","page":"enumerate","title":"Description","text":"","category":"section"},{"location":"operators/transformation/enumerate.html#","page":"enumerate","title":"enumerate","text":"enumerate returns an Observable that converts each value emitted by the source Observable into a tuple of its order number and the value itself.","category":"page"},{"location":"operators/transformation/enumerate.html#Example-1","page":"enumerate","title":"Example","text":"","category":"section"},{"location":"operators/transformation/enumerate.html#","page":"enumerate","title":"enumerate","text":"Get a value from the source with its order number","category":"page"},{"location":"operators/transformation/enumerate.html#","page":"enumerate","title":"enumerate","text":"using Rx\n\nsource = from([ 0.0, 0.2, 0.4, 0.6, 0.8, 1.0 ])\nsubscribe!(source |> enumerate(), LoggerActor{Tuple{Float64, Int}}())\n\n# output\n\n[LogActor] Data: (0.0, 1)\n[LogActor] Data: (0.2, 2)\n[LogActor] Data: (0.4, 3)\n[LogActor] Data: (0.6, 4)\n[LogActor] Data: (0.8, 5)\n[LogActor] Data: (1.0, 6)\n[LogActor] Completed","category":"page"},{"location":"operators/transformation/enumerate.html#See-also-1","page":"enumerate","title":"See also","text":"","category":"section"},{"location":"operators/transformation/enumerate.html#","page":"enumerate","title":"enumerate","text":"Operators, scan","category":"page"},{"location":"actors/types/sync.html#actor_sync-1","page":"Sync","title":"Sync actor","text":"","category":"section"},{"location":"actors/types/sync.html#","page":"Sync","title":"Sync","text":"sync","category":"page"},{"location":"actors/types/sync.html#Rx.sync","page":"Sync","title":"Rx.sync","text":"sync(actor::A) where A\n\nCreation operator for the SyncActor actor.\n\nExamples\n\nusing Rx\n\nactor  = LoggerActor{Int}()\nsynced = sync(actor)\nsynced isa SyncActor{Int, LoggerActor{Int}}\n\n# output\ntrue\n\n\nSee also: SyncActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/sync.html#","page":"Sync","title":"Sync","text":"SyncActor","category":"page"},{"location":"actors/types/sync.html#Rx.SyncActor","page":"Sync","title":"Rx.SyncActor","text":"SyncActor{D, A}(actor::A) where D where A\n\nSync actor provides a synchronized interface to wait for an actor to be notified with a complete event.\n\nExamples\n\nusing Rx\n\nsource = timer(1, 1) |> take(3)\nactor  = LoggerActor{Int}()\nsynced = SyncActor{Int, LoggerActor{Int}}(actor)\n\nsubscrption = subscribe!(source, synced)\n\nwait(synced)\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Completed\n\n\nSee also: Actor, sync\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#observables_api-1","page":"Observables","title":"Observables API","text":"","category":"section"},{"location":"api/observables.html#","page":"Observables","title":"Observables","text":"Any observable-like should implement a valid subscribable logic.","category":"page"},{"location":"api/observables.html#Traits-1","page":"Observables","title":"Traits","text":"","category":"section"},{"location":"api/observables.html#","page":"Observables","title":"Observables","text":"SubscribableTrait\nas_subscribable\nValidSubscribable\nInvalidSubscribable","category":"page"},{"location":"api/observables.html#Rx.SubscribableTrait","page":"Observables","title":"Rx.SubscribableTrait","text":"Abstract type for all possible subscribable traits\n\nSee also: ValidSubscribable, InvalidSubscribable\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Rx.as_subscribable","page":"Observables","title":"Rx.as_subscribable","text":"as_subscribable(::Type)\n\nThis function checks subscribable trait behavior specification. Can be used explicitly to specify subscribable trait behavior for any object.\n\nExamples\n\nusing Rx\n\nstruct MyArbitraryType end\nRx.as_subscribable(::Type{<:MyArbitraryType}) = ValidSubscribable{Int}()\n\nprintln(as_subscribable(MyArbitraryType) ===ValidSubscribable{Int}())\n;\n\n# output\n\ntrue\n\n\n\n\n\n\n","category":"function"},{"location":"api/observables.html#Rx.ValidSubscribable","page":"Observables","title":"Rx.ValidSubscribable","text":"Valid subscribable trait behavior. Valid subscribable can be used in subscribe! function.\n\nSee also: SubscribableTrait, Subscribable\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Rx.InvalidSubscribable","page":"Observables","title":"Rx.InvalidSubscribable","text":"Default subscribable trait behavior for all types. Invalid subscribable cannot be used in subscribe! function, doing so will throw an error.\n\nSee also: SubscribableTrait, subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Types-1","page":"Observables","title":"Types","text":"","category":"section"},{"location":"api/observables.html#","page":"Observables","title":"Observables","text":"Subscribable\nsubscribe!\non_subscribe!","category":"page"},{"location":"api/observables.html#Rx.Subscribable","page":"Observables","title":"Rx.Subscribable","text":"Super type for any subscribable object. Automatically specifies a ValidSubscribable trait behavior.\n\nExamples\n\nusing Rx\n\nstruct MySubscribable <: Subscribable{Int} end\n\nprintln(Rx.as_subscribable(MySubscribable) === ValidSubscribable{Int}())\n;\n\n# output\n\ntrue\n\n\nSee also: SubscribableTrait, ValidSubscribable\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Rx.subscribe!","page":"Observables","title":"Rx.subscribe!","text":"subscribe!(subscribable::T, actor::S) where T where S\n\nsubscribe! function is used to attach an actor to subscribable. It also checks types of subscribable and actors to be a valid Subscribable and Actor objects respectively. Passing not valid subscribable or/and actor object will throw an error.\n\nArguments\n\nsubscribable: valid subscribable object\nactor: valid actor object\n\nExamples\n\nusing Rx\n\nsource = from((1, 2, 3))\nsubscribe!(source, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 2\n[LogActor] Data: 3\n[LogActor] Completed\n\nusing Rx\n\nsource = from((1, 2, 3))\nsubscribe!(source, 1)\n;\n\n# output\n\nERROR: Type Int64 is not a valid actor type.\n[...]\n\nusing Rx\n\nsource = from((1, 2, 3))\nsubscribe!(1, logger())\n;\n\n# output\n\nERROR: Type Int64 is not a valid subscribable type.\n[...]\n\n\n\n\n\n","category":"function"},{"location":"api/observables.html#Rx.on_subscribe!","page":"Observables","title":"Rx.on_subscribe!","text":"on_subscribe!(subscribable, actor)\n\nEach valid subscribable object have to define its own method for on_subscribe! function which specifies subscription logic and has return a valid Teardown object.\n\nArguments\n\nsubscribable: Subscribable object\nactor: Actor object\n\nExamples\n\nusing Rx\n\nstruct MySubscribable <: Subscribable{Int} end\n\nfunction Rx.on_subscribe!(subscribable::MySubscribable, actor)\n    next!(actor, 0)\n    complete!(actor)\n    return VoidTeardown()\nend\n\nsubscribe!(MySubscribable(), logger())\n;\n\n# output\n\n[LogActor] Data: 0\n[LogActor] Completed\n\nSee also: Subscribable, Teardown, logger\n\n\n\n\n\n","category":"function"},{"location":"api/observables.html#Errors-1","page":"Observables","title":"Errors","text":"","category":"section"},{"location":"api/observables.html#","page":"Observables","title":"Observables","text":"InvalidSubscribableTraitUsageError\nInconsistentActorWithSubscribableDataTypesError\nMissingOnSubscribeImplementationError","category":"page"},{"location":"api/observables.html#Rx.InvalidSubscribableTraitUsageError","page":"Observables","title":"Rx.InvalidSubscribableTraitUsageError","text":"This error will be thrown if subscribe! function is called with invalid subscribable object\n\nSee also: subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Rx.InconsistentActorWithSubscribableDataTypesError","page":"Observables","title":"Rx.InconsistentActorWithSubscribableDataTypesError","text":"This error will be thrown if subscribe! function is called with inconsistent subscribable and actor objects\n\nSee also: subscribe!\n\n\n\n\n\n","category":"type"},{"location":"api/observables.html#Rx.MissingOnSubscribeImplementationError","page":"Observables","title":"Rx.MissingOnSubscribeImplementationError","text":"This error will be thrown if Julia cannot find specific method of 'on_subscribe!()' function for given subscribable and actor\n\nSee also: on_subscribe!\n\n\n\n\n\n","category":"type"},{"location":"operators/mathematical/sum.html#operator_sum-1","page":"sum","title":"Sum Operator","text":"","category":"section"},{"location":"operators/mathematical/sum.html#","page":"sum","title":"sum","text":"sum","category":"page"},{"location":"operators/mathematical/sum.html#Base.sum","page":"sum","title":"Base.sum","text":"sum(; from = nothing)\n\nCreates a sum operator, which applies a sum accumulator function over the source Observable, and returns the accumulated result when the source completes, given an optional initial value.\n\nThe sum operator is similar to reduce(T, T, +) (see reduce).\n\nArguments\n\nfrom: optional initial accumulation value, if nothing first value will be used instead\n\nProducing\n\nStream of type <: Subscribable{L} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> sum(), logger())\n;\n\n# output\n\n[LogActor] Data: 903\n[LogActor] Completed\n\n\nusing Rx\n\nsource = from([ i for i in 1:42 ])\nsubscribe!(source |> sum(from = 97), logger())\n;\n\n# output\n\n[LogActor] Data: 1000\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, reduce, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/mathematical/sum.html#Description-1","page":"sum","title":"Description","text":"","category":"section"},{"location":"operators/mathematical/sum.html#","page":"sum","title":"sum","text":"sum operates on an Observable of objects on which + is defined. When the source Observable completes, it emits the sum of all previous items. The sum operator is similar to reduce(T, T, +) (see reduce).","category":"page"},{"location":"operators/mathematical/sum.html#See-also-1","page":"sum","title":"See also","text":"","category":"section"},{"location":"operators/mathematical/sum.html#","page":"sum","title":"sum","text":"Operators, reduce","category":"page"},{"location":"actors/types/void.html#actor_void-1","page":"Void","title":"Void actor","text":"","category":"section"},{"location":"actors/types/void.html#","page":"Void","title":"Void","text":"void","category":"page"},{"location":"actors/types/void.html#Rx.void","page":"Void","title":"Rx.void","text":"void()\nvoid(::Type{T}) where T\n\nCreation operator for the VoidActor actor.\n\nExamples\n\nusing Rx\n\nactor = void(Int)\nactor isa VoidActor{Int}\n\n# output\ntrue\n\n\nSee also: VoidActor, AbstractActor\n\n\n\n\n\n","category":"function"},{"location":"actors/types/void.html#","page":"Void","title":"Void","text":"VoidActor","category":"page"},{"location":"actors/types/void.html#Rx.VoidActor","page":"Void","title":"Rx.VoidActor","text":"VoidActor{D}() where D\n\nVoid actor does nothing with input data, error and complete events, can be useful for debugging (e.g. to start side-effects with tap operator)\n\nExamples\n\nusing Rx\n\nsource = from([ 0, 1, 2 ])\nactor  = VoidActor{Int}()\n\nsubscribe!(source, actor)\n;\n\n# output\n\n\nSee also: Actor, void, tap\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy.html#observable_proxy-1","page":"Proxy","title":"Proxy Observable","text":"","category":"section"},{"location":"observables/types/proxy.html#","page":"Proxy","title":"Proxy","text":"ProxyObservable might help to create a custom operator. It wraps either source and/or actor with their proxied versions providing additional custom logic for on_subscribe! and/or for on_next!, on_error!, on_complete! methods.","category":"page"},{"location":"observables/types/proxy.html#","page":"Proxy","title":"Proxy","text":"proxy\nProxyObservable","category":"page"},{"location":"observables/types/proxy.html#Rx.proxy","page":"Proxy","title":"Rx.proxy","text":"proxy(::Type{D}, source, proxy) where D\n\nCreation operator for the ProxyObservable with a given source and proxy objects.\n\nExample\n\nusing Rx\n\nsource = from(1:5)\n\nstruct MyCustomProxy <: ActorProxy end\n\nstruct MyCustomActor{A} <: Actor{Int}\n    actor :: A\nend\n\nRx.on_next!(actor::MyCustomActor, data::Int) = next!(actor.actor, data ^ 2)\nRx.on_error!(actor::MyCustomActor, err)      = error!(actor.actor, err)\nRx.on_complete!(actor::MyCustomActor)        = complete!(actor.actor)\n\nRx.actor_proxy!(proxy::MyCustomProxy, actor::A) where A = MyCustomActor{A}(actor)\n\nproxied = proxy(Int, source, MyCustomProxy())\n\nsubscribe!(proxied, logger())\n;\n\n# output\n\n[LogActor] Data: 1\n[LogActor] Data: 4\n[LogActor] Data: 9\n[LogActor] Data: 16\n[LogActor] Data: 25\n[LogActor] Completed\n\nSee also: ProxyObservable, ActorProxy, SourceProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/proxy.html#Rx.ProxyObservable","page":"Proxy","title":"Rx.ProxyObservable","text":"ProxyObservable{D}(proxied_source, proxy)\n\nAn interface for proxied Observables.\n\nSee also: proxy\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy.html#","page":"Proxy","title":"Proxy","text":"ActorProxy\nSourceProxy\nActorSourceProxy","category":"page"},{"location":"observables/types/proxy.html#Rx.ActorProxy","page":"Proxy","title":"Rx.ActorProxy","text":"ActorProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidActorProxy trait behavior. Each ActorProxy must implement its own method for actor_proxy!(proxy, actor) function which have to return a valid actor object.\n\nSee also: proxy, actor_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy.html#Rx.SourceProxy","page":"Proxy","title":"Rx.SourceProxy","text":"SourceProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidSourceProxy trait behavior. Each SourceProxy must implement its own method for source_proxy!(proxy, source) function which have to return a valid subscribable object.\n\nSee also: proxy, source_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy.html#Rx.ActorSourceProxy","page":"Proxy","title":"Rx.ActorSourceProxy","text":"ActorSourceProxy\n\nCan be used as a super type for common proxy object. Automatically specifies ValidActorSourceProxy trait behavior. Each ActorSourceProxy must implement its own method for source_proxy!(proxy, source) function which have to return a valid subscribable object and also for actor_proxy!(proxy, actor) function which have to return a valid actor object..\n\nSee also: proxy, actor_proxy!, source_proxy!\n\n\n\n\n\n","category":"type"},{"location":"observables/types/proxy.html#","page":"Proxy","title":"Proxy","text":"actor_proxy!\nsource_proxy!","category":"page"},{"location":"observables/types/proxy.html#Rx.actor_proxy!","page":"Proxy","title":"Rx.actor_proxy!","text":"actor_proxy!(proxy, actor)\n\nThis is function is used to wrap an actor with its proxied version given a particular proxy object. Must return another actor. Each valid ActorProxy and ActorSourceProxy must implement its own method for actor_proxy! function.\n\nSee also: proxy, ActorProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"observables/types/proxy.html#Rx.source_proxy!","page":"Proxy","title":"Rx.source_proxy!","text":"source_proxy!(proxy, source)\n\nThis is function is used to wrap a source with its proxied version given a particular proxy object. Must return another Observable. Each valid SourceProxy and ActorSourceProxy must implement its own method for source_proxy! function.\n\nSee also: proxy, SourceProxy, ActorSourceProxy\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/to_array.html#operator_to_array-1","page":"to_array","title":"Uppercase Operator","text":"","category":"section"},{"location":"operators/transformation/to_array.html#","page":"to_array","title":"to_array","text":"to_array","category":"page"},{"location":"operators/transformation/to_array.html#Rx.to_array","page":"to_array","title":"Rx.to_array","text":"to_array()\n\nCreates a to_array operator, which reduces all values into a single array and returns this result when the source completes.\n\nProducing\n\nStream of type <: Subscribable{Vector{L}} where L refers to type of source stream\n\nExamples\n\nusing Rx\n\nsource = from([ 1, 2, 3 ])\nsubscribe!(source |> to_array(), LoggerActor{Vector{Int}}())\n;\n\n# output\n\n[LogActor] Data: [1, 2, 3]\n[LogActor] Completed\n\n\nSee also: AbstractOperator, InferableOperator, ProxyObservable, logger\n\n\n\n\n\n","category":"function"},{"location":"operators/transformation/to_array.html#See-also-1","page":"to_array","title":"See also","text":"","category":"section"},{"location":"operators/transformation/to_array.html#","page":"to_array","title":"to_array","text":"Operators, map, lowercase","category":"page"},{"location":"operators/transformation/about.html#Transformation-category-1","page":"About transformation operators","title":"Transformation category","text":"","category":"section"},{"location":"operators/transformation/about.html#","page":"About transformation operators","title":"About transformation operators","text":"There are operators for different purposes, and they may be categorized as: creation, transformation, filtering, joining, multicasting, error handling, utility, etc. In the following list you will find all the operators organized in transformation category.","category":"page"},{"location":"operators/transformation/about.html#","page":"About transformation operators","title":"About transformation operators","text":"map\nscan\nenumerate\nuppercase\nlowercase\nto_array","category":"page"},{"location":"operators/transformation/about.html#See-also-1","page":"About transformation operators","title":"See also","text":"","category":"section"},{"location":"operators/transformation/about.html#","page":"About transformation operators","title":"About transformation operators","text":"Operators","category":"page"}]
}
