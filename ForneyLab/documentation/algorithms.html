

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Algorithms &mdash; ForneyLab.jl 0.4.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  
    <link rel="top" title="ForneyLab.jl 0.4.0 documentation" href="index.html"/>
        <link rel="next" title="Diagnostics and reporting" href="diagnostics_reporting.html"/>
        <link rel="prev" title="Nodes" href="nodes.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="index.html" class="fa fa-home"> ForneyLab.jl</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphical_model.html">Setting up the graphical model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#the-factorgraph-type">The <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#nodes">Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#the-edge-type">The <tt class="docutils literal"><span class="pre">Edge</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#chaining-factor-graph-sections">Chaining factor graph sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#interfacing-to-and-from-the-graph">Interfacing to and from the graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="distributions_messages.html">Probability distributions and messages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#the-probabilitydistribution-type">The <tt class="docutils literal"><span class="pre">ProbabilityDistribution</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#marginals">Marginals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nodes.html">Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#the-anatomy-of-nodes">The anatomy of nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#message-calculation-rules">Message calculation rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#approximate-rules">Approximate rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#composite-nodes">Composite nodes</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#execution">Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="#schedules">Schedules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-sum-product-algorithm">The sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-loopy-sum-product-algorithm">The loopy sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-variational-message-passing-algorithm">The variational message passing algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-expectation-propagation-algorithm">The expectation propagation algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics_reporting.html">Diagnostics and reporting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#inspect-objects">Inspect objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#draw-graphs-and-subgraphs">Draw graphs and subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#verify-algorithm-execution">Verify algorithm execution</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">ForneyLab.jl</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Algorithms</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/algorithms.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="algorithms">
<h1>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h1>
<p>Algorithms that are to be executed on a <a class="reference internal" href="graphical_model.html#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a>, are instances of the <tt class="docutils literal"><span class="pre">InferenceAlgorithm</span></tt> type. ForneyLab implements <tt class="docutils literal"><span class="pre">SumProduct</span></tt>, <tt class="docutils literal"><span class="pre">LoopySumProduct</span></tt>, <tt class="docutils literal"><span class="pre">VariationalBayes</span></tt> and <tt class="docutils literal"><span class="pre">ExpectationPropagation</span></tt> algorithms. While algorithm specific details differ, the general mechanisms for construction and execution remain the same. For example, the <tt class="docutils literal"><span class="pre">SumProduct</span></tt> algorithm is defined as follows.</p>
<dl class="type">
<dt id="SumProduct">
<em class="property">type </em><tt class="descname">SumProduct</tt><a class="headerlink" href="#SumProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>A specific algorithm type for sum-product message passing:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> SumProduct</span>
    <span class="n">execute</span><span class="p">::</span><span class="n">Function</span>
    <span class="n">schedule</span><span class="p">::</span><span class="n">Schedule</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">SumProduct</span></tt> algorithm holds a <tt class="docutils literal"><span class="pre">schedule</span></tt>, which is executed upon calling the <tt class="docutils literal"><span class="pre">execute</span></tt> function.</p>
</dd></dl>

<p>ForneyLab implements several constructors for algorithm types. Construction of an algorithm generally consists of these steps:</p>
<ol class="arabic simple">
<li>Generate a schedule towards specific interfaces, wraps and/or write buffers;</li>
<li>Infer the message distribution types for each entry in the schedule.</li>
</ol>
<p>Inference of the distribution types in step 2 allows for efficient execution of the update rules later on.</p>
<div class="section" id="execution">
<h2>Execution<a class="headerlink" href="#execution" title="Permalink to this headline">¶</a></h2>
<p>After construction, an algorithm can be executed. For efficiency reasons, computations are in-place operations performed on the messages stored on the interfaces. Instead of making a new <tt class="docutils literal"><span class="pre">ProbabilityDistribution</span></tt> instance, the parameters of the existing <tt class="docutils literal"><span class="pre">message.payload</span></tt> are altered. Algorithm execution generally consists of the following steps:</p>
<ol class="arabic simple">
<li>Ensure that initial outbound messages are present on each outbound interface in the schedule;</li>
<li>For each entry in the schedule, pre-compile the update rule;</li>
<li>In turn execute each entry in schedule, in-place updating the pre-set messages.</li>
</ol>
<p>Steps 1 and 2 are the preparation phase. The pre-compilation in step 2 ensures that functions <tt class="docutils literal"><span class="pre">run</span></tt> and <tt class="docutils literal"><span class="pre">step</span></tt> only need to call a single pre-compiled update function for each entry in the schedule.</p>
<p>The following functions are exported:</p>
<dl class="function">
<dt id="execute">
<tt class="descname">execute</tt><big>(</big><em>algorithm</em><big>)</big><a class="headerlink" href="#execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes <tt class="docutils literal"><span class="pre">algorithm</span></tt> on the current graph.</p>
</dd></dl>

<dl class="function">
<dt id="step">
<tt class="descname">step</tt><big>(</big><em>algorithm</em>, <em>direction::Symbol</em><big>)</big><a class="headerlink" href="#step" title="Permalink to this definition">¶</a></dt>
<dd><p>Buffer and wrap aware version of <tt class="docutils literal"><span class="pre">execute(algorithm)</span></tt>. Performs the following:</p>
<ol class="arabic simple">
<li>Read an element from all read-buffers defined in the current graph</li>
<li><tt class="docutils literal"><span class="pre">execute(algorithm)</span></tt></li>
<li>Write an element to all write-buffers defined in the current graph</li>
<li>Propagate messages along all wraps defined in current graph in the corresponding direction</li>
</ol>
<p>Before calling <tt class="docutils literal"><span class="pre">step</span></tt>, the algorithm must first be prepared by calling <tt class="docutils literal"><span class="pre">prepare!(algorithm)</span></tt>. Preparing the algorithm ensures that initial messages are set and all update rules are pre-compiled.
Shorthand version of the function <tt class="docutils literal"><span class="pre">step(algorithm)</span></tt> exists and is an alias for <tt class="docutils literal"><span class="pre">step(algorithm,</span> <span class="pre">:forward)</span></tt></p>
</dd></dl>

<dl class="function">
<dt id="run">
<tt class="descname">run</tt><big>(</big><em>algorithm; direction::Symbol</em><big>)</big><a class="headerlink" href="#run" title="Permalink to this definition">¶</a></dt>
<dd><p>Prepares the algorithm and calls <tt class="docutils literal"><span class="pre">step(algorithm)</span></tt> repeatedly until one of the read-buffers is exhausted or until the end of the block is reached. Keyword argument <tt class="docutils literal"><span class="pre">direction</span></tt> is optional and by default takes <tt class="docutils literal"><span class="pre">:forward</span></tt> value.</p>
</dd></dl>

</div>
<div class="section" id="schedules">
<h2>Schedules<a class="headerlink" href="#schedules" title="Permalink to this headline">¶</a></h2>
<p>Algorithms executed on factor graphs are usually based on <em>message passing</em>. In message passing, a sequence of messages is calculated, where the next message usually depends on previously calculated messages. A <tt class="docutils literal"><span class="pre">Schedule</span></tt> defines a sequence of message calculations.</p>
<dl class="type">
<dt id="Schedule">
<em class="property">type </em><tt class="descname">Schedule</tt><a class="headerlink" href="#Schedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines a sequence of <a class="reference internal" href="distributions_messages.html#Message" title="Message"><tt class="xref jl jl-class docutils literal"><span class="pre">Message</span></tt></a> calculations:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">typealias</span><span class="nc"> Schedule</span> <span class="n">Vector</span><span class="p">{</span><span class="n">ScheduleEntry</span><span class="p">}</span>
</pre></div>
</div>
<dl class="function">
<dt id="Schedule.execute">
<tt class="descname">execute</tt><big>(</big><em>schedule::Schedule</em><big>)</big><a class="headerlink" href="#Schedule.execute" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes all entries in <tt class="docutils literal"><span class="pre">schedule</span></tt> once.</p>
</dd></dl>

</dd></dl>

<dl class="type">
<dt id="ScheduleEntry">
<em class="property">type </em><tt class="descname">ScheduleEntry</tt><a class="headerlink" href="#ScheduleEntry" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies a message calculation operation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> ScheduleEntry</span>
    <span class="n">node</span><span class="p">::</span><span class="n">Node</span>
    <span class="n">outbound_interface_id</span><span class="p">::</span><span class="kt">Int64</span>
    <span class="n">rule</span><span class="p">::</span><span class="n">Function</span>  <span class="c"># Refers to the general message calculation rule; for example sumProductRule! or variationalRule!.</span>
    <span class="n">execute</span><span class="p">::</span><span class="n">Function</span> <span class="c"># Compiled rule call: () -&gt; rule(node, Val{outbound_interface_id}, rule_arguments...).</span>

    <span class="c"># And some omitted fields</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">ScheduleEntry</span></tt> is the workhorse of ForneyLab. Most importantly, the <tt class="docutils literal"><span class="pre">execute</span></tt> field holds the pre-compiled (anonymous) function for the message update. All other fields are simply there to facilitate the proper construction of <tt class="docutils literal"><span class="pre">execute</span></tt>. The <tt class="docutils literal"><span class="pre">execute</span></tt> function is called upon execution of the <tt class="docutils literal"><span class="pre">ScheduleEntry</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="the-sum-product-algorithm">
<h2>The sum-product algorithm<a class="headerlink" href="#the-sum-product-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/04_simple_kalman.ipynb">Kalman filter</a></p>
</div>
<p>The <tt class="docutils literal"><span class="pre">SumProduct</span></tt> algorithm comes with several constructors and an automatic scheduler for generating a sum-product message passing schedule.</p>
<p>Algorithm constructors for sum-product message passing only work for acyclic graphs. For graphs with cycles, the <tt class="docutils literal"><span class="pre">LoopySumProduct</span></tt> algorithm can be used.</p>
<dl class="function">
<dt>
<tt class="descname">SumProduct</tt><big>(</big><em>::FactorGraph</em><big>)</big></dt>
<dd><p>Generates a sum-product algorithm with a schedule towards interfaces connected to write buffers and wraps.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">SumProduct</tt><big>(</big><em>::Interface</em><big>)</big></dt>
<dd><p>Defines a sum-product algorithm with a schedule towards the argument interface.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">SumProduct</tt><big>(</big><em>::Vector{Interface}</em><big>)</big></dt>
<dd><p>Generates a sum-product algorithm that at least propagates messages to all interfaces in the argument vector.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">SumProduct</tt><big>(</big><em>::Edge</em><big>)</big></dt>
<dd><p>Defines a sum-product algorithm with a schedule towards the forward and backward interfaces of the argument edge and calculates the corresponding marginal.</p>
</dd></dl>

<div class="section" id="automatic-scheduler">
<h3>Automatic scheduler<a class="headerlink" href="#automatic-scheduler" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="generateSumProductSchedule">
<tt class="descname">generateSumProductSchedule</tt><big>(</big><em>::FactorGraph</em><big>)</big><a class="headerlink" href="#generateSumProductSchedule" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a sum-product message passing schedule that passes messages towards interfaces concerning write buffers and wraps as defined by the argument graph. The scheduler works through depth first search.</p>
</dd></dl>

</div>
</div>
<div class="section" id="the-loopy-sum-product-algorithm">
<h2>The loopy sum-product algorithm<a class="headerlink" href="#the-loopy-sum-product-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/05_loopy_belief_propagation.ipynb">Loopy belief propagation</a></p>
</div>
<p>The <tt class="docutils literal"><span class="pre">LoopySumProduct</span></tt> algorithm is similar to the <tt class="docutils literal"><span class="pre">SumProduct</span></tt> algorithm, but then for graphs with cycles.</p>
<dl class="function">
<dt id="LoopySumProduct">
<tt class="descname">LoopySumProduct</tt><big>(</big><em>::FactorGraph; breaker_messages=Dict{Interface</em>, <em>Message}()</em>, <em>n_iterations=50</em>, <em>...</em><big>)</big><a class="headerlink" href="#LoopySumProduct" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a loopy sum-product algorithm that propagates to defined write buffers and wraps. Breaker messages specified by the <tt class="docutils literal"><span class="pre">breaker_messages</span></tt> dictionary are pre-set on the corresponding interfaces. From there a standard sum-product message passing schedule is generated. Upon execution, this schedule is repeated for <tt class="docutils literal"><span class="pre">n_iterations</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">LoopySumProduct</tt><big>(</big><em>::Interface; breaker_messages=Dict{Interface</em>, <em>Message}()</em>, <em>n_iterations=50</em>, <em>...</em><big>)</big></dt>
<dd><p>Constructs a loopy sum-product algorithm towards an interface.</p>
</dd></dl>

</div>
<div class="section" id="the-variational-message-passing-algorithm">
<h2>The variational message passing algorithm<a class="headerlink" href="#the-variational-message-passing-algorithm" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<div class="last line-block">
<div class="line"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/07_naive_variational_message_passing.ipynb">Naive variational message passing</a></div>
<div class="line"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/08_structured_variational_message_passing.ipynb">Structured variational message passing</a></div>
</div>
</div>
<p>The <tt class="docutils literal"><span class="pre">VariationalBayes</span></tt> algorithm implements variational message passing (VMP) as described by Dauwels in his 2007 paper &#8220;On variational message passing on factor graphs&#8221;. The algorithm supports both mean field and structured VMP. ForneyLab implements several algorithm specific constructors, an auto scheduler and several helper types required for execution.</p>
<p>The factorization of the recognition distribution is stored under the <tt class="docutils literal"><span class="pre">factorization</span></tt> field of the algorithm and references the different subgraphs. The actual recognition distributions are stored under the <tt class="docutils literal"><span class="pre">recognition_distributions</span></tt> field and the number of iterations under <tt class="docutils literal"><span class="pre">:n_iterations</span></tt>.</p>
<div class="section" id="algorithm-constructors">
<h3>Algorithm constructors<a class="headerlink" href="#algorithm-constructors" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="VariationalBayes">
<tt class="descname">VariationalBayes</tt><big>(</big><em>recognition_distribution_types::Dict</em>, <em>::FactorGraph; n_iterations=50</em><big>)</big><a class="headerlink" href="#VariationalBayes" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a VMP algorithm to calculate the messages towards write buffers and timewraps defined on the argument graph, with a as specified by the <tt class="docutils literal"><span class="pre">recognition_distribution_types</span></tt> dictionary.</p>
</dd></dl>

<p>The factorization of the recognition distribution is specified by the edge(array)-to-distribution-type dictionary called <tt class="docutils literal"><span class="pre">recognition_distribution_types</span></tt>. The conventions for passing the recognition distribution factorization are best specified by example.</p>
<p>The snippet below specifies a full (mean field) factorization around a Gaussian node:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">algo</span> <span class="o">=</span> <span class="n">VariationalBayes</span><span class="p">(</span><span class="n">Dict</span><span class="p">(</span>
    <span class="n">eg</span><span class="p">(:</span><span class="n">mean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Gaussian</span><span class="p">,</span>
    <span class="n">eg</span><span class="p">(:</span><span class="n">prec</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">Gamma</span><span class="p">,</span>
    <span class="n">eg</span><span class="p">(:</span><span class="n">out</span><span class="p">)</span>  <span class="o">=&gt;</span> <span class="n">Gaussian</span><span class="p">))</span>
</pre></div>
</div>
<p>For defining a full factorization over multiple graph sections, edges with similar distributions are grouped in a column vector:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">algo</span> <span class="o">=</span> <span class="n">VariationalBayes</span><span class="p">(</span><span class="n">Dict</span><span class="p">(</span>
    <span class="p">[</span><span class="n">eg</span><span class="p">(:</span><span class="n">mean1</span><span class="p">),</span> <span class="n">eg</span><span class="p">(:</span><span class="n">mean2</span><span class="p">)]</span> <span class="o">=&gt;</span> <span class="n">Gaussian</span><span class="p">,</span>
    <span class="p">[</span><span class="n">eg</span><span class="p">(:</span><span class="n">prec1</span><span class="p">),</span> <span class="n">eg</span><span class="p">(:</span><span class="n">prec2</span><span class="p">)]</span> <span class="o">=&gt;</span> <span class="n">Gamma</span><span class="p">,</span>
    <span class="p">[</span><span class="n">eg</span><span class="p">(:</span><span class="n">out1</span><span class="p">),</span>  <span class="n">eg</span><span class="p">(:</span><span class="n">out2</span><span class="p">)</span> <span class="p">]</span> <span class="o">=&gt;</span> <span class="n">Gaussian</span><span class="p">))</span>
</pre></div>
</div>
<p>Edges belonging to the same cluster are grouped in the rows of a matrix. The following snippet specifies a joint recognition distribution over the mean and precision (note the lack of a separating comma):</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">algo</span> <span class="o">=</span> <span class="n">VariationalBayes</span><span class="p">(</span><span class="n">Dict</span><span class="p">(</span>
    <span class="p">[</span><span class="n">eg</span><span class="p">(:</span><span class="n">mean</span><span class="p">)</span> <span class="n">eg</span><span class="p">(:</span><span class="n">prec</span><span class="p">)]</span> <span class="o">=&gt;</span> <span class="n">NormalGamma</span><span class="p">,</span>
     <span class="n">eg</span><span class="p">(:</span><span class="n">out</span><span class="p">)</span>             <span class="o">=&gt;</span> <span class="n">Gaussian</span><span class="p">))</span>
</pre></div>
</div>
<p>For more examples, consult the VMP demos.</p>
</div>
<div class="section" id="id1">
<h3>Automatic scheduler<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="generateVariationalBayesSchedule!">
<tt class="descname">generateVariationalBayesSchedule!</tt><big>(</big><em>::RecognitionFactorization</em>, <em>::FactorGraph</em><big>)</big><a class="headerlink" href="#generateVariationalBayesSchedule!" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates and stores an (internal and external) schedule for VMP.</p>
</dd></dl>

</div>
<div class="section" id="vmp-specific-types">
<h3>VMP specific types<a class="headerlink" href="#vmp-specific-types" title="Permalink to this headline">¶</a></h3>
<dl class="type">
<dt id="Subgraph">
<em class="property">type </em><tt class="descname">Subgraph</tt><a class="headerlink" href="#Subgraph" title="Permalink to this definition">¶</a></dt>
<dd><p>The internal edges of subgraphs are non-overlapping clusters, which together define the factorization of the recognition distribution. The VMP algorithm executes updates for the subgraphs (corresponding with the factors) in turn:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Subgraph</span>
    <span class="n">internal_edges</span><span class="p">::</span><span class="n">Set</span><span class="p">{</span><span class="n">Edge</span><span class="p">}</span>
    <span class="n">internal_schedule</span><span class="p">::</span><span class="n">Schedule</span> <span class="c"># Schedule for internal message passing</span>
    <span class="n">external_schedule</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Node</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span> <span class="c"># Schedule for marginal updates</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="RecognitionFactorization">
<em class="property">type </em><tt class="descname">RecognitionFactorization</tt><a class="headerlink" href="#RecognitionFactorization" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">RecognitionFactorization</span></tt> type stores the variational factorization of the graph. The <tt class="docutils literal"><span class="pre">edge_to_subgraph</span></tt> attribute contains a dictionary for fast subgraph lookup:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> RecognitionFactorization</span>
    <span class="n">factors</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Subgraph</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>
    <span class="n">edge_to_subgraph</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Edge</span><span class="p">,</span> <span class="n">Subgraph</span><span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

<dl class="type">
<dt id="RecognitionDistribution">
<em class="property">type </em><tt class="descname">RecognitionDistribution</tt><a class="headerlink" href="#RecognitionDistribution" title="Permalink to this definition">¶</a></dt>
<dd><p>The <tt class="docutils literal"><span class="pre">RecognitionDistribution</span></tt> type stores local recognition distributions. The <tt class="docutils literal"><span class="pre">edges</span></tt> attribute defined the local set of edges on which <tt class="docutils literal"><span class="pre">distribution</span></tt> is defined:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> RecognitionDistribution</span>
    <span class="n">distribution</span><span class="p">::</span><span class="n">ProbabilityDistribution</span>
    <span class="n">edges</span><span class="p">::</span><span class="n">Set</span><span class="p">{</span><span class="n">Edge</span><span class="p">}</span> <span class="c"># Edges on which the distribution is defined</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="the-expectation-propagation-algorithm">
<h2>The expectation propagation algorithm<a class="headerlink" href="#the-expectation-propagation-algorithm" title="Permalink to this headline">¶</a></h2>
<p>The <tt class="docutils literal"><span class="pre">ExpectationPropagation</span></tt> algorithm automatically derives an expectation propagation message passing algorithm. The expectation propagation (EP) algorithm is similar to (loopy) belief propagation as implemented by the sum-product algorithm. For some nodes, the exact sum-product messages cannot be expressed analytically in the desired form, rendering the sum-product algorithm unusable. In these cases, the EP algorithm provides a solution by projecting the &#8216;difficult&#8217; messages on the family of desired distributions. The interfaces that generate the &#8216;difficult&#8217; messages are called sites. The outbound messages on the sites are called &#8220;expectations&#8221;, and represent local approximations to the &#8216;true&#8217; messages. The inbound messages on the sites are called &#8220;cavity distributions&#8221;, and they capture the effect of the rest of the graph (usually prior + other sites) on the marginal. Since the expectation message depends on the cavity distribution, the EP algorithm creates implicit loops in the factor graph. Because of this, the EP message passing schedule has to be executed multiple times for the messages to converge.</p>
<p>The expectation messages on the sites are calculated by the <a class="reference internal" href="nodes.html#expectationRule!" title="expectationRule!"><tt class="xref jl jl-func docutils literal"><span class="pre">expectationRule!()</span></tt></a>. This rule should be implemented for all nodes connected to sites. In contrast to <a class="reference internal" href="nodes.html#sumProductRule!" title="sumProductRule!"><tt class="xref jl jl-func docutils literal"><span class="pre">sumProductRule!()</span></tt></a>, <a class="reference internal" href="nodes.html#expectationRule!" title="expectationRule!"><tt class="xref jl jl-func docutils literal"><span class="pre">expectationRule!()</span></tt></a> also consumes the inbound message on the outbound interface (site).</p>
<dl class="function">
<dt id="ExpectationPropagation">
<tt class="descname">ExpectationPropagation</tt><big>(</big><em>sites::Vector{Interface}; ...</em><big>)</big><a class="headerlink" href="#ExpectationPropagation" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates an EP algorithm to incrementally approximate the marginal distributions of the variables (edges) connected to the specified &#8216;sites&#8217;. The generated message passing schedule will respect the order of the sites.
The following optional keyword arguments may be passed:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">num_iterations</span></tt>: a positive integer indicating the maximum number of iterations (default=100).</li>
<li><tt class="docutils literal"><span class="pre">callback</span></tt>: a function that is called after each iteration. This function can be used for example to check converge or to collect intermediate results. If the callback function returns <tt class="docutils literal"><span class="pre">true</span></tt>, the algorithm is terminated.</li>
</ul>
</dd></dl>

</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="diagnostics_reporting.html" class="btn btn-neutral float-right" title="Diagnostics and reporting">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="nodes.html" class="btn btn-neutral" title="Nodes"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>