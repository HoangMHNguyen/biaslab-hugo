

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Nodes &mdash; ForneyLab.jl 0.4.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  
    <link rel="top" title="ForneyLab.jl 0.4.0 documentation" href="index.html"/>
        <link rel="next" title="Algorithms" href="algorithms.html"/>
        <link rel="prev" title="Probability distributions and messages" href="distributions_messages.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="index.html" class="fa fa-home"> ForneyLab.jl</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="graphical_model.html">Setting up the graphical model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#the-factorgraph-type">The <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#nodes">Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#the-edge-type">The <tt class="docutils literal"><span class="pre">Edge</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#chaining-factor-graph-sections">Chaining factor graph sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="graphical_model.html#interfacing-to-and-from-the-graph">Interfacing to and from the graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="distributions_messages.html">Probability distributions and messages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#the-probabilitydistribution-type">The <tt class="docutils literal"><span class="pre">ProbabilityDistribution</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#marginals">Marginals</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-anatomy-of-nodes">The anatomy of nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#message-calculation-rules">Message calculation rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#approximate-rules">Approximate rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="#composite-nodes">Composite nodes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#execution">Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#schedules">Schedules</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-sum-product-algorithm">The sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-loopy-sum-product-algorithm">The loopy sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-variational-message-passing-algorithm">The variational message passing algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-expectation-propagation-algorithm">The expectation propagation algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics_reporting.html">Diagnostics and reporting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#inspect-objects">Inspect objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#draw-graphs-and-subgraphs">Draw graphs and subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#verify-algorithm-execution">Verify algorithm execution</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">ForneyLab.jl</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Nodes</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/nodes.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="nodes">
<h1>Nodes<a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h1>
<p>This chapter describes the implementation of nodes in ForneyLab. For more details on specific node types, use Julia&#8217;s help functionality (<tt class="docutils literal"><span class="pre">?AdditionNode</span></tt>), or have a look at the source files, such as <tt class="docutils literal"><span class="pre">src/nodes/addition.jl</span></tt>.</p>
<div class="section" id="the-anatomy-of-nodes">
<h2>The anatomy of nodes<a class="headerlink" href="#the-anatomy-of-nodes" title="Permalink to this headline">¶</a></h2>
<p>Each node type is a subtype of abstract <tt class="docutils literal"><span class="pre">Node</span></tt>. A node should contain at least the fields <tt class="docutils literal"><span class="pre">id</span></tt>, <tt class="docutils literal"><span class="pre">interfaces</span></tt> and <tt class="docutils literal"><span class="pre">i</span></tt>. Let&#8217;s look at the definition of the built-in <tt class="xref jl jl-class docutils literal"><span class="pre">AdditionNode</span></tt>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> AdditionNode</span> <span class="o">&lt;:</span> <span class="n">Node</span>
    <span class="n">id</span><span class="p">::</span><span class="n">Symbol</span>
    <span class="n">interfaces</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Interface</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">i</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Interface</span><span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The field <tt class="docutils literal"><span class="pre">i</span></tt> stores &#8216;named handles&#8217; to make accessing the interfaces convenient, for example if we want to access the output interface we can use <tt class="docutils literal"><span class="pre">node.i[:out]</span></tt>. The <tt class="docutils literal"><span class="pre">interfaces</span></tt> array always contains one or more <a class="reference internal" href="#Interface" title="Interface"><tt class="xref jl jl-class docutils literal"><span class="pre">Interface</span></tt></a> instances, and the index in this array is called the &#8220;interface id&#8221;. The calling signature of a node constructor varies, but it always includes the optional keyword argument <tt class="docutils literal"><span class="pre">id</span></tt>. A <tt class="docutils literal"><span class="pre">Node</span></tt> can be copied using <tt class="docutils literal"><span class="pre">copy(src::Node;</span> <span class="pre">id=:new_id)</span></tt>, where <tt class="docutils literal"><span class="pre">:new_id</span></tt> will become the id of the copy. The copy contains the exact internal state of the original, but has no edges connected to it.</p>
<dl class="type">
<dt id="Interface">
<em class="property">type </em><tt class="descname">Interface</tt><a class="headerlink" href="#Interface" title="Permalink to this definition">¶</a></dt>
<dd><p>An Interface belongs to a node and can be partnered to another <tt class="docutils literal"><span class="pre">Interface</span></tt> to form an <a class="reference internal" href="graphical_model.html#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a>. It can be viewed as an half-edge that can be combined with another half-edge to form a complete <a class="reference internal" href="graphical_model.html#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a>.</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Interface</span>
    <span class="n">node</span><span class="p">::</span><span class="n">Node</span> <span class="c"># Reference to the Node it is part of</span>
    <span class="n">edge</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">AbstractEdge</span><span class="p">,</span> <span class="n">Void</span><span class="p">)</span> <span class="c"># Reference to the Edge it is part of</span>
    <span class="n">partner</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Interface</span><span class="p">,</span> <span class="n">Void</span><span class="p">)</span> <span class="c"># Partner it is connected to</span>
    <span class="n">message</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">Message</span><span class="p">,</span> <span class="n">Void</span><span class="p">)</span>   <span class="c"># Outbound message</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">message</span></tt> field may contain a <a class="reference internal" href="distributions_messages.html#Message" title="Message"><tt class="xref jl jl-class docutils literal"><span class="pre">Message</span></tt></a>, which is the <em>outbound message</em> calculated according to the node function. This means that if an interface is the tail of an <a class="reference internal" href="graphical_model.html#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a>, its <tt class="docutils literal"><span class="pre">message</span></tt> field contains the <em>forward message</em> on that edge. Similarly, if the interface is the head of the edge, its <tt class="docutils literal"><span class="pre">message</span></tt> field contains the <em>backward message</em>.</p>
</dd></dl>

</div>
<div class="section" id="message-calculation-rules">
<h2>Message calculation rules<a class="headerlink" href="#message-calculation-rules" title="Permalink to this headline">¶</a></h2>
<p>A factor node captures a specific <em>node function</em>, which involves the variables that are represented by the connected edges. The <tt class="xref jl jl-class docutils literal"><span class="pre">AdditionNode</span></tt> for example captures the addition function: <tt class="docutils literal"><span class="pre">f(in1,in2,out)</span> <span class="pre">=</span> <span class="pre">δ(in1+in2-out)</span></tt>. When running a message passing algorithm on a <a class="reference internal" href="graphical_model.html#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a>, the node function specifies how the outbound messages are calculated from the inbound messages. An outbound message is calculated according to a message calculation rule, also simply called <em>rule</em>. Rules are implemented for specific nodes and message types, making heavy use of Julia&#8217;s multiple dispatch system.</p>
<p>ForneyLab comes with the following built-in rules:</p>
<dl class="function">
<dt id="sumProductRule!">
<tt class="descname">sumProductRule!</tt><big>(</big><em>node::Node</em>, <em>outbound_interface_index::Type{Val{i}}</em>, <em>outbound_dist::ProbabilityDistribution</em>, <em>inbound_messages...</em><big>)</big><a class="headerlink" href="#sumProductRule!" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the outbound message from the incoming messages on the other interfaces according to the sum-product algorithm.
Example implementation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">function</span><span class="nf"> sumProductRule</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="p">::</span><span class="n">AdditionNode</span><span class="p">,</span>
                         <span class="n">outbound_interface_index</span><span class="p">::</span><span class="n">Type</span><span class="p">{</span><span class="n">Val</span><span class="p">{</span><span class="mi">3</span><span class="p">}},</span>
                         <span class="n">outbound_dist</span><span class="p">::</span><span class="n">Gaussian</span><span class="p">,</span>
                         <span class="n">msg_in1</span><span class="p">::</span><span class="n">Message</span><span class="p">{</span><span class="n">Gaussian</span><span class="p">},</span>
                         <span class="n">msg_in2</span><span class="p">::</span><span class="n">Message</span><span class="p">{</span><span class="n">Gaussian</span><span class="p">},</span>
                         <span class="n">msg_out</span><span class="p">::</span><span class="kt">Any</span><span class="p">)</span>
    <span class="c"># Calculate outbound message on interface 3 (:out)</span>
    <span class="c"># according to the sum-product rule</span>

    <span class="c"># Perform computations as in in-place operation on outbound_dist</span>

    <span class="k">return</span> <span class="n">outbound_dist</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The calling signature consists of:</p>
<ol class="arabic simple">
<li>The node;</li>
<li>The interface id (index in node.interfaces) of the outbound interface as a value type;</li>
<li>The payload of the message currently present on the outbound interface;</li>
<li>The inbound messages on <em>all</em> interfaces of the node (ordered by interface id).</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="variationalRule!">
<tt class="descname">variationalRule!</tt><big>(</big><em>node::Node</em>, <em>outbound_interface_index::Type{Val{i}}</em>, <em>outbound_dist::ProbabilityDistribution</em>, <em>marginals_and_messages...</em><big>)</big><a class="headerlink" href="#variationalRule!" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#sumProductRule!" title="sumProductRule!"><tt class="xref jl jl-func docutils literal"><span class="pre">sumProductRule!()</span></tt></a>, but on some interfaces marginals are required instead of messages. This rule is used for variational message passing (vmp).
Example implementation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">function</span><span class="nf"> variationalRule</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="p">::</span><span class="n">GaussianNode</span><span class="p">,</span>
                          <span class="n">outbound_interface_index</span><span class="p">::</span><span class="n">Type</span><span class="p">{</span><span class="n">Val</span><span class="p">{</span><span class="mi">1</span><span class="p">}},</span>
                          <span class="n">outbound_dist</span><span class="p">::</span><span class="n">Gaussian</span><span class="p">,</span>
                          <span class="n">marg_mean</span><span class="p">::</span><span class="kt">Any</span><span class="p">,</span>
                          <span class="n">marg_prec</span><span class="p">::</span><span class="n">Gamma</span><span class="p">,</span>
                          <span class="n">marg_y</span><span class="p">::</span><span class="n">Gaussian</span><span class="p">)</span>
    <span class="c"># Calculate outbound message on interface 1 (:mean)</span>
    <span class="c"># according to the variational rule</span>

    <span class="c"># Perform computations as in in-place operation on outbound_dist</span>

    <span class="k">return</span> <span class="n">outbound_dist</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The calling signature consists of:</p>
<ol class="arabic simple">
<li>The node;</li>
<li>The interface id (index in node.interfaces) of the outbound interface as a value type;</li>
<li>The payload of the message currently present on the outbound interface;</li>
<li>The inbound messages/marginals on <em>all</em> interfaces of the node (ordered by interface id).</li>
</ol>
</dd></dl>

<dl class="function">
<dt id="expectationRule!">
<tt class="descname">expectationRule!</tt><big>(</big><em>node::Node</em>, <em>outbound_interface_index::Type{Val{i}}</em>, <em>outbound_dist::Gaussian</em>, <em>inbound_messages...</em><big>)</big><a class="headerlink" href="#expectationRule!" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#sumProductRule!" title="sumProductRule!"><tt class="xref jl jl-func docutils literal"><span class="pre">sumProductRule!()</span></tt></a>, but also the inbound message on the outbound interface is consumed (this messages carries the cavity distrubution). This calculation rule is used in the expectation propagation algorithm.</p>
<p>The calling signature consists of:</p>
<ol class="arabic simple">
<li>The node;</li>
<li>The interface id (index in node.interfaces) of the outbound interface as a value type;</li>
<li>The payload of the message currently present on the outbound interface;</li>
<li>The inbound messages on <em>all</em> interfaces of the node (ordered by interface id).</li>
</ol>
</dd></dl>

<p>Not all message calculation rules have to be implemented for every node, just the ones that will be used. Similarly, the message calculation rule does not have to be implemented for a specific outbound interface of a specific node if that outbound message never has to be calculated.</p>
<p>To find out which message calculation rules are implemented for a specific node, use the <tt class="docutils literal"><span class="pre">rules</span></tt> function:</p>
<dl class="function">
<dt id="rules">
<tt class="descname">rules</tt><big>(</big><em>node_type::DataType</em><span class="optional">[</span>, <em>rule::Function; outbound::Int=0</em><span class="optional">]</span><big>)</big><a class="headerlink" href="#rules" title="Permalink to this definition">¶</a></dt>
<dd><p>Print all message calculation rules implemented for <tt class="docutils literal"><span class="pre">node_type</span> <span class="pre">&lt;:</span> <span class="pre">Node</span></tt>.
Optionally, the list can be restricted to a specific rule, such as <tt class="docutils literal"><span class="pre">sumProductRule!</span></tt> or <tt class="docutils literal"><span class="pre">variationalRule!</span></tt>.
If keyword argument <tt class="docutils literal"><span class="pre">outbound</span></tt> is passed, only the rules for that outbound interface id are listed.</p>
</dd></dl>

</div>
<div class="section" id="approximate-rules">
<h2>Approximate rules<a class="headerlink" href="#approximate-rules" title="Permalink to this headline">¶</a></h2>
<p>A rule might not result in a convenient or tractable exact outbound message. In such cases, one might want to implement an <em>approximate rule</em>. For example, a difficult, non-Gaussian, outbound message might be approximated by a Gaussian outbound message using Laplace&#8217;s method or by moment matching. An approximate rule should have an extra argument to specify the type of approximation. For example:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">function</span><span class="nf"> sumProductRule</span><span class="o">!</span><span class="p">(</span><span class="n">node</span><span class="p">::</span><span class="n">GaussianNode</span><span class="p">{:</span><span class="n">mean</span><span class="p">}{:</span><span class="n">precision</span><span class="p">},</span>
                         <span class="n">outbound_interface_index</span><span class="p">::</span><span class="n">Type</span><span class="p">{</span><span class="n">Val</span><span class="p">{</span><span class="mi">3</span><span class="p">}},</span>
                         <span class="n">outbound_dist</span><span class="p">::</span><span class="n">Gaussian</span><span class="p">,</span>
                         <span class="n">msg_mean</span><span class="p">::</span><span class="n">Message</span><span class="p">{</span><span class="n">Gaussian</span><span class="p">},</span>
                         <span class="n">msg_prec</span><span class="p">::</span><span class="n">Message</span><span class="p">{</span><span class="n">Gamma</span><span class="p">},</span>
                         <span class="n">msg_out</span><span class="p">::</span><span class="kt">Any</span><span class="p">,</span>
                         <span class="n">approx</span><span class="p">::</span><span class="n">Type</span><span class="p">{</span><span class="n">MomentMatching</span><span class="p">})</span>
    <span class="c"># Approximate exact student&#39;s t message by a Gaussian through moment matching</span>
    <span class="o">...</span>

    <span class="k">return</span> <span class="n">outbound_dist</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The extra argument should be a subtype of <tt class="docutils literal"><span class="pre">ApproximationType</span></tt>. Built-in approximation types are <tt class="docutils literal"><span class="pre">Laplace</span></tt> and <tt class="docutils literal"><span class="pre">MomentMatching</span></tt>. By default, ForneyLab will only resort to an approximate rule if there is no exact rule that can handle the incoming messages. However, a the user can force a message to have a specific distribution type by passing the <tt class="docutils literal"><span class="pre">message_types</span></tt> keyword argument to the algorithm constructor. If there are multiple approximation types for the same approximating distribution type, the user can even specify the desired approximation:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># Force the use of the Laplace approximation on my_interface</span>
<span class="n">msg_types</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">{</span><span class="n">Interface</span><span class="p">,</span><span class="n">DataType</span><span class="p">}(</span>
                <span class="n">my_interface</span> <span class="o">=&gt;</span> <span class="n">Approximation</span><span class="p">{</span><span class="n">Gaussian</span><span class="p">,</span> <span class="n">Laplace</span><span class="p">}</span>
            <span class="p">)</span>
<span class="n">algo</span> <span class="o">=</span> <span class="n">SumProduct</span><span class="p">(</span><span class="n">message_types</span><span class="o">=</span><span class="n">msg_types</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="composite-nodes">
<h2>Composite nodes<a class="headerlink" href="#composite-nodes" title="Permalink to this headline">¶</a></h2>
<p>A node in which multiple node functions are combined into one node function is called a <tt class="docutils literal"><span class="pre">CompositeNode</span></tt> In ForneyLab 0.4 the composite node functionality is removed. It will be reintroduced in ForneyLab 0.5.</p>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="algorithms.html" class="btn btn-neutral float-right" title="Algorithms">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="distributions_messages.html" class="btn btn-neutral" title="Probability distributions and messages"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>