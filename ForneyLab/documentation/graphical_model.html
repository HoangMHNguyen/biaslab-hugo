

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Setting up the graphical model &mdash; ForneyLab.jl 0.4.0 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/julia.css" type="text/css" />
  
    <link rel="top" title="ForneyLab.jl 0.4.0 documentation" href="index.html"/>
        <link rel="next" title="Probability distributions and messages" href="distributions_messages.html"/>
        <link rel="prev" title="Introduction" href="introduction.html"/> 

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="http://julialang.org/"><img src="_static/julia-logo.svg" class="logo"></a>
        <!--
        <a href="index.html" class="fa fa-home"> ForneyLab.jl</a>
        -->
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="">Setting up the graphical model</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-factorgraph-type">The <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#nodes">Nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-edge-type">The <tt class="docutils literal"><span class="pre">Edge</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="#example">Example</a></li>
<li class="toctree-l2"><a class="reference internal" href="#chaining-factor-graph-sections">Chaining factor graph sections</a></li>
<li class="toctree-l2"><a class="reference internal" href="#interfacing-to-and-from-the-graph">Interfacing to and from the graph</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="distributions_messages.html">Probability distributions and messages</a><ul>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#the-probabilitydistribution-type">The <tt class="docutils literal"><span class="pre">ProbabilityDistribution</span></tt> type</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#messages">Messages</a></li>
<li class="toctree-l2"><a class="reference internal" href="distributions_messages.html#marginals">Marginals</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="nodes.html">Nodes</a><ul>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#the-anatomy-of-nodes">The anatomy of nodes</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#message-calculation-rules">Message calculation rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#approximate-rules">Approximate rules</a></li>
<li class="toctree-l2"><a class="reference internal" href="nodes.html#composite-nodes">Composite nodes</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="algorithms.html">Algorithms</a><ul>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#execution">Execution</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#schedules">Schedules</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-sum-product-algorithm">The sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-loopy-sum-product-algorithm">The loopy sum-product algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-variational-message-passing-algorithm">The variational message passing algorithm</a></li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html#the-expectation-propagation-algorithm">The expectation propagation algorithm</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="diagnostics_reporting.html">Diagnostics and reporting</a><ul>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#inspect-objects">Inspect objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#draw-graphs-and-subgraphs">Draw graphs and subgraphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="diagnostics_reporting.html#verify-algorithm-execution">Verify algorithm execution</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">ForneyLab.jl</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
    <li>Setting up the graphical model</li>
      <li class="wy-breadcrumbs-aside">
        
          <a href="_sources/graphical_model.txt" rel="nofollow"> View page source</a>
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="setting-up-the-graphical-model">
<h1>Setting up the graphical model<a class="headerlink" href="#setting-up-the-graphical-model" title="Permalink to this headline">¶</a></h1>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/01_basics.ipynb">Basics</a></p>
</div>
<p>Building the graphical model amounts to adding nodes and edges to a <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a>. This chapter introduces the main types and functions that are involved in setting up the graphical model.</p>
<div class="section" id="the-factorgraph-type">
<h2>The <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> type<a class="headerlink" href="#the-factorgraph-type" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="FactorGraph">
<em class="property">type </em><tt class="descname">FactorGraph</tt><a class="headerlink" href="#FactorGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>A directed graph consisting of factor nodes and edges:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> FactorGraph</span>
    <span class="n">nodes</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Node</span><span class="p">}</span> <span class="c"># Nodes</span>
    <span class="n">edges</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Edge</span><span class="p">}</span> <span class="c"># Edges</span>
    <span class="c"># and some internal stuff for attaching buffers etc...</span>
<span class="k">end</span>
</pre></div>
</div>
</dd></dl>

<p>Within ForneyLab, only one <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> instance can be active at a time, and it is referred to as &#8220;current graph&#8221;. Graph operations are always implictly applied to the current graph. The following functions are available to get/set the currently active <tt class="docutils literal"><span class="pre">FactorGraph</span></tt>:</p>
<dl class="function">
<dt id="currentGraph">
<tt class="descname">currentGraph</tt><big>(</big><big>)</big><a class="headerlink" href="#currentGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the currently active <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a> instance. A new <tt class="docutils literal"><span class="pre">FactorGraph</span></tt> is constructed if there is none.</p>
</dd></dl>

<dl class="function">
<dt id="setCurrentGraph">
<tt class="descname">setCurrentGraph</tt><big>(</big><em>graph::FactorGraph</em><big>)</big><a class="headerlink" href="#setCurrentGraph" title="Permalink to this definition">¶</a></dt>
<dd><p>Make <tt class="docutils literal"><span class="pre">graph</span></tt> the currently active factor graph.</p>
</dd></dl>

</div>
<div class="section" id="nodes">
<h2>Nodes<a class="headerlink" href="#nodes" title="Permalink to this headline">¶</a></h2>
<p>A node in a <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a> is always of a subtype of <tt class="docutils literal"><span class="pre">abstract</span> <span class="pre">Node</span></tt>. ForneyLab comes with a bunch of built-in nodes for commonly used functions, such as the <tt class="xref jl jl-class docutils literal"><span class="pre">AdditionNode</span></tt> and the <tt class="xref jl jl-class docutils literal"><span class="pre">EqualityNode</span></tt>. The <a class="reference internal" href="nodes.html"><em>Nodes</em></a> chapter describes the anatomy of nodes in more detail, as well as how to build custom nodes. The built-in nodes are located in <tt class="docutils literal"><span class="pre">src/nodes/</span></tt>. A node has a couple of required fields:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> MinimalNode</span> <span class="o">&lt;:</span> <span class="n">Node</span>
    <span class="n">id</span><span class="p">::</span><span class="n">Symbol</span>
    <span class="n">interfaces</span><span class="p">::</span><span class="n">Array</span><span class="p">{</span><span class="n">Interface</span><span class="p">,</span><span class="mi">1</span><span class="p">}</span>
    <span class="n">i</span><span class="p">::</span><span class="n">Dict</span><span class="p">{</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Interface</span><span class="p">}</span>
<span class="k">end</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">id</span></tt> field holds a unique id, which can be passed to the constructor as a keyword argument. The <tt class="docutils literal"><span class="pre">interfaces</span></tt> field holds a list of <a class="reference internal" href="nodes.html#Interface" title="Interface"><tt class="xref jl jl-class docutils literal"><span class="pre">Interface</span></tt></a> objects. An <a class="reference internal" href="#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a> connects two interfaces of different nodes to each other. The <tt class="docutils literal"><span class="pre">i</span></tt> field stores named handles to the interfaces, i.e. <tt class="docutils literal"><span class="pre">gain_node.i[:out]</span></tt> is equivalent to <tt class="docutils literal"><span class="pre">gain_node.interfaces[2]</span></tt>.</p>
<p>The calling signature of a node constructor depends on the specific type of the node, e.g.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">AdditionNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">my_adder</span><span class="p">)</span>  <span class="c"># Node func.: out = in1 + in2</span>
<span class="n">GainNode</span><span class="p">(</span><span class="n">gain</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">times_3</span><span class="p">)</span> <span class="c"># Node func.: out = 3.0 * in1</span>
</pre></div>
</div>
<p>A <tt class="docutils literal"><span class="pre">Node</span></tt> constructor always adds the constructed node to the current graph. Nodes in the current graph can be accessed through the function <tt class="docutils literal"><span class="pre">node(id::Symbol)</span></tt> (which is aliased by the function <tt class="docutils literal"><span class="pre">n(id::Symbol)</span></tt>), e.g.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">node</span><span class="p">(:</span><span class="n">my_adder</span><span class="p">)</span>
<span class="n">n</span><span class="p">(:</span><span class="n">my_adder</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="the-edge-type">
<h2>The <tt class="docutils literal"><span class="pre">Edge</span></tt> type<a class="headerlink" href="#the-edge-type" title="Permalink to this headline">¶</a></h2>
<dl class="type">
<dt id="Edge">
<em class="property">type </em><tt class="descname">Edge</tt><a class="headerlink" href="#Edge" title="Permalink to this definition">¶</a></dt>
<dd><p>An <tt class="docutils literal"><span class="pre">Edge</span></tt> is directed and connects two <a class="reference internal" href="nodes.html#Interface" title="Interface"><tt class="xref jl jl-class docutils literal"><span class="pre">Interface</span></tt></a> instances of different nodes:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="k">type</span><span class="nc"> Edge</span> <span class="o">&lt;:</span> <span class="n">AbstractEdge</span>
    <span class="c"># [tail]------&gt;[head]</span>
    <span class="n">id</span><span class="p">::</span><span class="n">Symbol</span>
    <span class="n">tail</span><span class="p">::</span><span class="n">Interface</span>
    <span class="n">head</span><span class="p">::</span><span class="n">Interface</span>
    <span class="n">marginal</span><span class="p">::</span><span class="n">Union</span><span class="p">(</span><span class="n">ProbabilityDistribution</span><span class="p">,</span> <span class="n">Void</span><span class="p">)</span>
<span class="k">end</span>
</pre></div>
</div>
<p>An edge represents a variable, so the <tt class="docutils literal"><span class="pre">marginal</span></tt> field may contain the marginal <tt class="xref jl jl-class docutils literal"><span class="pre">ProbabilityDistribution</span></tt> over that variable.</p>
<p>In general, an <tt class="docutils literal"><span class="pre">Edge</span></tt> is constructed by passing the tail and head interfaces:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">node1</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">out</span><span class="p">],</span> <span class="n">n</span><span class="p">(:</span><span class="n">node2</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="k">in</span><span class="p">],</span> <span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">my_edge</span><span class="p">)</span>
</pre></div>
</div>
<p>For nodes that only have one interface (i.e. <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt>) or that are symmetrical (i.e. <tt class="xref jl jl-class docutils literal"><span class="pre">EqualityNode</span></tt>), it is also possible to pass the node instead of the interface:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">Edge</span><span class="p">(</span><span class="n">TerminalNode</span><span class="p">(),</span> <span class="n">EqualityNode</span><span class="p">())</span>
</pre></div>
</div>
<p>In such cases the constructor will automatically pick the first free interface of the node.</p>
<p>The <tt class="docutils literal"><span class="pre">Edge</span></tt> constructor will add the edge to the current graph (the head and tail nodes should already belong to that graph).</p>
</dd></dl>

<p>Strictly speaking, a factor graph edge does not need to be directed. However, in ForneyLab all edges are directed to have a consistent meaning for terms like &#8220;forward message&#8221;, &#8220;backward messages&#8221;, and &#8220;forward pass&#8221;. Apart from that, the edge direction has no functional consequences.</p>
<p>ForneyLab does not allow half-edges: every <a class="reference internal" href="#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a> should be connected to two nodes at all times. Open ended edges should be terminated by a <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt>, which has just one interface.</p>
<p>Edges in the current graph can be accessed through the function <tt class="docutils literal"><span class="pre">edge(id::Symbol)</span></tt> (which is aliased by the function <tt class="docutils literal"><span class="pre">eg(id::Symbol)</span></tt>), e.g.:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">edge</span><span class="p">(:</span><span class="n">my_edge</span><span class="p">)</span>
<span class="n">eg</span><span class="p">(:</span><span class="n">my_edge</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="example">
<h2>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h2>
<p>Consider the following simple factor graph:</p>
<div class="highlight-julia"><div class="highlight"><pre>      <span class="o">|</span> <span class="n">C1</span>    <span class="o">|</span> <span class="n">C2</span>
      <span class="o">|</span>       <span class="o">|</span>
  <span class="n">X1</span>  <span class="n">v</span>   <span class="n">X2</span>  <span class="n">v</span>   <span class="n">X3</span>
<span class="o">----&gt;</span><span class="p">[</span><span class="o">+</span><span class="p">]</span><span class="o">----&gt;</span><span class="p">[</span><span class="o">+</span><span class="p">]</span><span class="o">----&gt;</span>
</pre></div>
</div>
<p>ForneyLab does not allow &#8216;half-edges&#8217; that are connected to just one node. Instead, half-edges should be terminated by a <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt>. Taking this into account, one could implement this factor graph as follows:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">FactorGraph</span><span class="p">()</span>

<span class="c"># Create nodes</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">t_x1</span><span class="p">)</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">t_c1</span><span class="p">)</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">t_c2</span><span class="p">)</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">t_x3</span><span class="p">)</span>
<span class="n">AdditionNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">adder_1</span><span class="p">)</span>
<span class="n">AdditionNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">adder_2</span><span class="p">)</span>

<span class="c"># Create edges</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">t_x1</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder_1</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">in1</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">t_c1</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder_1</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">in2</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">adder_1</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">out</span><span class="p">],</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder_2</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">in1</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">t_c2</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder_2</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">in2</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">adder_2</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">out</span><span class="p">],</span> <span class="n">n</span><span class="p">(:</span><span class="n">t_x3</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="section" id="chaining-factor-graph-sections">
<h2>Chaining factor graph sections<a class="headerlink" href="#chaining-factor-graph-sections" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/03_random_walk.ipynb">Random walk</a></p>
</div>
<p>In practical situations it is common for a factor graph to be a concatination of identical sections. In such cases it might not be necessary to build the entire factor graph explictly. Instead, it is possible to just build one section, and define how the sections are chained together. This can be done in ForneyLab by defining <em>wraps</em>:</p>
<div class="highlight-julia"><div class="highlight"><pre><span class="c"># Random walk chain</span>
<span class="c">#          | C</span>
<span class="c">#          |</span>
<span class="c">#    X[n]  v  X[n+1]</span>
<span class="c"># ...----&gt;[+]-------&gt; ...</span>

<span class="n">g</span> <span class="o">=</span> <span class="n">FactorGraph</span><span class="p">()</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">X_prev</span><span class="p">)</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">X_next</span><span class="p">)</span>
<span class="n">TerminalNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">C</span><span class="p">)</span>
<span class="n">AdditionNode</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="p">:</span><span class="n">adder</span><span class="p">)</span>

<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">X_prev</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder</span><span class="p">)</span><span class="o">.</span><span class="p">[:</span><span class="n">in1</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">C</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">adder</span><span class="p">)</span><span class="o">.</span><span class="p">[:</span><span class="n">in2</span><span class="p">])</span>
<span class="n">Edge</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">adder</span><span class="p">)</span><span class="o">.</span><span class="n">i</span><span class="p">[:</span><span class="n">out</span><span class="p">],</span> <span class="n">n</span><span class="p">(:</span><span class="n">X_next</span><span class="p">))</span>

<span class="n">Wrap</span><span class="p">(</span><span class="n">n</span><span class="p">(:</span><span class="n">X_next</span><span class="p">),</span> <span class="n">n</span><span class="p">(:</span><span class="n">X_prev</span><span class="p">))</span> <span class="c"># X_next becomes X_prev in the next section</span>
</pre></div>
</div>
<dl class="type">
<dt id="Wrap">
<em class="property">type </em><tt class="descname">Wrap</tt><a class="headerlink" href="#Wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>A <tt class="docutils literal"><span class="pre">Wrap</span></tt> is a special kind of <a class="reference internal" href="#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a> that connects to <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt> instances such that the involved <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a> is &#8216;folded&#8217;. One :class: <cite>TerminalNode</cite> is considered to be the tail of the wrap, while the other one is considered to be the head of it. Message transfer from <em>tail</em> to <em>head</em> and vice versa is handled by the <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a> function.</p>
<dl class="function">
<dt id="Wrap.Wrap">
<tt class="descname">Wrap</tt><big>(</big><em>tail::TerminalNode</em>, <em>head::TerminalNode; id::Symbol</em>, <em>block_size::Int64</em><big>)</big><a class="headerlink" href="#Wrap.Wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructs a wrap from <tt class="docutils literal"><span class="pre">tail</span></tt> to <tt class="docutils literal"><span class="pre">head</span></tt> in the currently active graph. The keyword arguments <tt class="docutils literal"><span class="pre">id</span></tt> and <tt class="docutils literal"><span class="pre">block_size</span></tt> are optional. If <tt class="docutils literal"><span class="pre">block_size</span></tt> argument is not specified, the constructed wrap supports only forward message passing. To support backward message passing through wrap, <tt class="docutils literal"><span class="pre">block_size</span></tt> should be provided to the constructor. It is prohibited to construct wraps with different block sizes.</p>
</dd></dl>

<dl class="function">
<dt id="Wrap.wrap">
<tt class="descname">wrap</tt><big>(</big><em>id::Symbol</em>, <em>graph::FactorGraph=currentGraph()</em><big>)</big><a class="headerlink" href="#Wrap.wrap" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the <tt class="docutils literal"><span class="pre">Wrap</span></tt> in <tt class="docutils literal"><span class="pre">graph</span></tt> with the specified <tt class="docutils literal"><span class="pre">id</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt id="Wrap.wraps">
<tt class="descname">wraps</tt><big>(</big><em>graph::FactorGraph</em>, <em>graph::FactorGraph=currentGraph()</em><big>)</big><a class="headerlink" href="#Wrap.wraps" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the set of all <tt class="docutils literal"><span class="pre">Wrap</span></tt> instances present in <tt class="docutils literal"><span class="pre">graph</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">wraps</tt><big>(</big><em>node::TerminalNode</em>, <em>graph::FactorGraph=currentGraph()</em><big>)</big></dt>
<dd><p>Returns the set of all <tt class="docutils literal"><span class="pre">Wrap</span></tt> instances in which <tt class="docutils literal"><span class="pre">node</span></tt> is involved. Note that a node can take the role of source in multiple wraps, but it can be a sink at most once.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="interfacing-to-and-from-the-graph">
<h2>Interfacing to and from the graph<a class="headerlink" href="#interfacing-to-and-from-the-graph" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><strong>Demo:</strong> <a class="reference external" href="https://github.com/spsbrats/ForneyLab.jl/blob/master/demo/04_simple_kalman.ipynb">Kalman filter</a></p>
</div>
<p>To link a <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a> to the outside world, so-called buffers can be used. A buffer can be used to insert data into the graph (&#8216;read buffer&#8217;) or to extract data from the graph (&#8216;write buffer&#8217;). Some helper functions are available to work with these buffers.</p>
<div class="section" id="input-to-the-graph">
<h3>Input to the graph<a class="headerlink" href="#input-to-the-graph" title="Permalink to this headline">¶</a></h3>
<p>Read buffers hold input data that is read into the graph from the outside world. The data is stored in a <tt class="docutils literal"><span class="pre">buffer</span></tt> vector that is attached to a <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt>. Every time the <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a> function is called, the first element of each read buffer is moved to the value field of the corresponding terminal node. The following functions are available to attach and detach read buffers:</p>
<dl class="function">
<dt id="attachReadBuffer">
<tt class="descname">attachReadBuffer</tt><big>(</big><em>node::TerminalNode</em>, <em>buffer::Vector</em><big>)</big><a class="headerlink" href="#attachReadBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Attaches the vector <tt class="docutils literal"><span class="pre">buffer</span></tt> as a read buffer to the <tt class="xref jl jl-class docutils literal"><span class="pre">TerminalNode</span></tt> <tt class="docutils literal"><span class="pre">node</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">attachReadBuffer</tt><big>(</big><em>nodes::Vector{TerminalNode}</em>, <em>buffer::Vector</em><big>)</big></dt>
<dd><p>Attaches a read buffer to a batch of nodes. This function can be used to couple input data with a graph that models multiple (time) slices, such as a (mini-)batch. On each call to <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a>, a number of elements equal to the length of the <tt class="docutils literal"><span class="pre">nodes</span></tt> vector is moved from the beginning of <tt class="docutils literal"><span class="pre">buffer</span></tt> to the value fields of <tt class="docutils literal"><span class="pre">nodes</span></tt> (in their respective order).</p>
</dd></dl>

<dl class="function">
<dt id="detachReadBuffer">
<tt class="descname">detachReadBuffer</tt><big>(</big><em>node::TerminalNode</em><big>)</big><a class="headerlink" href="#detachReadBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Detach the read buffer from <tt class="docutils literal"><span class="pre">node</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="output-from-the-graph">
<h3>Output from the graph<a class="headerlink" href="#output-from-the-graph" title="Permalink to this headline">¶</a></h3>
<p>Write buffers allow message payloads and edge marginals to be extracted from the <a class="reference internal" href="#FactorGraph" title="FactorGraph"><tt class="xref jl jl-class docutils literal"><span class="pre">FactorGraph</span></tt></a>. A write buffer is a <tt class="docutils literal"><span class="pre">Vector{ProbabilityDistribution}</span></tt>, and can be attached to either an <a class="reference internal" href="nodes.html#Interface" title="Interface"><tt class="xref jl jl-class docutils literal"><span class="pre">Interface</span></tt></a> or an <a class="reference internal" href="#Edge" title="Edge"><tt class="xref jl jl-class docutils literal"><span class="pre">Edge</span></tt></a>. Every call to <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a> will result in exactly one element (message payload or marginal) being pushed onto every write buffer. The following functions are available:</p>
<dl class="function">
<dt id="attachWriteBuffer">
<tt class="descname">attachWriteBuffer</tt><big>(</big><em>interface::Interface</em><big>)</big><a class="headerlink" href="#attachWriteBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an empty write buffer attached to <tt class="docutils literal"><span class="pre">interface</span></tt>. Every call to <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a> will result in the payload of the outbound message on <tt class="docutils literal"><span class="pre">interface</span></tt> being pushed to the buffer.</p>
</dd></dl>

<dl class="function">
<dt id="detachWriteBuffer">
<tt class="descname">detachWriteBuffer</tt><big>(</big><em>interface::Interface</em><big>)</big><a class="headerlink" href="#detachWriteBuffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Detaches the write buffer attached to <tt class="docutils literal"><span class="pre">interface</span></tt>.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">attachWriteBuffer</tt><big>(</big><em>edge::Edge</em><big>)</big></dt>
<dd><p>Returns an empty write buffer attached to <tt class="docutils literal"><span class="pre">edge</span></tt>. Every call to <a class="reference internal" href="algorithms.html#step" title="step"><tt class="xref jl jl-func docutils literal"><span class="pre">step()</span></tt></a> will result in the marginal on <tt class="docutils literal"><span class="pre">edge</span></tt> being pushed to the buffer.</p>
</dd></dl>

<dl class="function">
<dt>
<tt class="descname">detachWriteBuffer</tt><big>(</big><em>edge::Edge</em><big>)</big></dt>
<dd><p>Detaches the write buffer attached to <tt class="docutils literal"><span class="pre">edge</span></tt>.</p>
</dd></dl>

</div>
<div class="section" id="resetting-the-graph">
<h3>Resetting the graph<a class="headerlink" href="#resetting-the-graph" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="detachBuffers">
<tt class="descname">detachBuffers</tt><big>(</big><em>graph::FactorGraph=currentGraph()</em><big>)</big><a class="headerlink" href="#detachBuffers" title="Permalink to this definition">¶</a></dt>
<dd><p>Detaches all read and write buffers.</p>
</dd></dl>

<dl class="function">
<dt id="emptyWriteBuffers">
<tt class="descname">emptyWriteBuffers</tt><big>(</big><em>graph::FactorGraph=currentGraph()</em><big>)</big><a class="headerlink" href="#emptyWriteBuffers" title="Permalink to this definition">¶</a></dt>
<dd><p>Truncates the contents of all write buffers.</p>
</dd></dl>

<dl class="function">
<dt id="clearMessages!">
<tt class="descname">clearMessages!</tt><big>(</big><em>graph::FactorGraph=currentGraph()</em><big>)</big><a class="headerlink" href="#clearMessages!" title="Permalink to this definition">¶</a></dt>
<dd><p>Clears all messages in the graph.</p>
</dd></dl>

</div>
</div>
</div>


          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="distributions_messages.html" class="btn btn-neutral float-right" title="Probability distributions and messages">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="introduction.html" class="btn btn-neutral" title="Introduction"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
    </p>
  </div>

  <a href="https://github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.4.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>